[{"title":"第八章、计算机视频、音频","date":"2016-05-13T16:00:00.000Z","path":"2016/05/14/8-computer-network/","text":"1、简介1-1、Internet上传输音频视频面临的问题 1、与普通通信的区别 音频视频通信的特点：占用的带宽高，网速需要恒定，延迟要低数据通信：没有严格要求 2、Internet传输视频面临的问题 延迟：进行实时视频交互时，延迟不能大。对于非交互式的音频视频影响不大 带宽不稳定：解决办法，客户端播放器设置缓存。播放器从缓存中均匀读取数据。 3、目前因特网上的音频、视频分类 流式存储音频/视频–边下载边播放（好处，不用下载，保护版权，不能随意下载） 流式实况音频/视频–边录制边发送（通过网络，现场直播） 交互式音频/视频–实时交互式通信（QQ视频聊天） 4、流式实况音频/视频架构 2、IP电话 平时的电话是使用电路交换狭义的IP电话:在Internet是传输电话信息。广义的IP电话：即时通信都理解为IP电话（视频聊天） IP电话的几种连接方法 3、Qos服务Qos主要有一下几种实现形式：3-1、对数据包进行标记 3-2、对数据输入的源地址进行分类 3-3、对数据流量进行通信管制 3-4、流量调度机制 3-5、呼叫接纳","tags":[{"name":"Computer Network","slug":"Computer-Network","permalink":"http://yoursite.com/tags/Computer-Network/"}]},{"title":"第七章、网络安全（下）","date":"2016-05-12T16:00:00.000Z","path":"2016/05/13/7-computer-network-2/","text":"6、Internet上使用的安全协议6-1、安全嵌套字协议SSL 位于应用层和传输层之间作用：应用层给传输层数据之前，需要对数据进行加密。对于网站登录名、密码时，需要使用SSL协议，此时由http变为https SSL实现原理： A访问网站，网站将自己的公钥给A A将利用对称秘钥对登录信息进行加密 A利用web的公钥对对称秘钥加密，随后把数据发给服务器 服务器利用私钥解密，利用解密出来的对称秘钥对数据进行解密 Internet上常用的使用SSl协议的端口 imaps tcp-993 pop3s tcp-995 smtps tcp-465 https tcp-443 SSL提供的功能 SSL服务器鉴别：允许用户证实服务器的身份。具有SSL功能的浏览器维持一张表，上面有一些可信赖的认证中心CA和他们的公钥。 加密的SSL会话：客户和服务器交互的所有数据，都在发送方加密，在接收方解密。 SSL客户端鉴别 ：允许服务器正式客户身份。 6-2、网络层安全IPSec 网络层安全是底层加密。 IPsec工作原理： 服务器和客户端进行通信之前，进行协商，进行SA（安全关联） SA主要是协商是否签名、是否加密。协商好后进行传输。 SA只签名不加密，使用AH协议；如果既签名又加密，使用ESP协议。 IPsec中的主要协议 AH（鉴别首部）：鉴别源点和检查数据的完整性，但不能保密（只签名） ESP（封装安全有效载荷）：比AH复杂，鉴别源点，检查数据的完整性和提供保密（签名+加密） 6-2-1、鉴别首部协议AH 数据包在传输层和网络层之间插入一个AH首部,IP数据包的协议字段设置为51 协议详解： 下一个首部：TCP字段在什么位置 有效负载长度 保留 安全参数索引SPI：固定值 序列号：数据包序号 鉴别数据：鉴别数据包 6-2-2、封装安全有效载荷ESP协议IP数据包的协议字段设置为50协议详解： ESP首部：安全参数所以SPI、序号。 利用ESP鉴别进行数据的鉴定。 注：数字签名、对称加密、非对称加密均为应用层安全SSL应用层和传输层之间的安全 6-3、数据链路层安全 数据包进入路由器时，进行加密，出路由器时，进行解密。 PPP身份验证 ADSL用户密码登录 防火墙 网络层防火墙：看不到数据包的内容。基于数据包的源地址、目标地址、协议和端口来进行控制流量 应用级防火墙：能够看到数据包中的内容。基于数据包的源地址、目标地址、协议和端口、用户名、时间段、内容进行控制流量","tags":[{"name":"Computer Network","slug":"Computer-Network","permalink":"http://yoursite.com/tags/Computer-Network/"}]},{"title":"第七章、网络安全（上）","date":"2016-05-11T16:00:00.000Z","path":"2016/05/12/7-computer-network-1/","text":"1、网络安全介绍计算机网络面临的威胁： 截获：被动攻击，从网络中窃听他人通信的内容 中断：主动攻击，有意中断他人在网络上的通信（arp欺骗） 篡改：主动攻击，故意篡改传输报文（将访问的网站结果重定向） 伪造：主动攻击，伪造信息在网络上传输（选用多个服务器利用大包ping攻击的服务器。这样别人就没有带宽对目标服务器进行访问，这就是DDos攻击） cain软件，实现用户密码的截获，以及篡改。实现的原理是使用ARP欺骗，在解析网关时，都解析成cain所在的服务器地址，所以，所有的报文后期都传输给cain所在的服务器。 2、病毒和木马恶意程序： 计算机病毒：附加在普通软件中，安装时，一并安装到本地。 计算机蠕虫：消耗计算机资源，CPU，内存 特洛伊木马：特点：需要与外界通信。举例：盗号木马、远程控制木马。排查： netstat -n查看可以会话 逻辑炸弹：满足特定条件触发 3、网络安全的两种加密技术3-1、对称加密 加密和解密的秘钥相同加密算法：数据机密标准DES加密秘钥：56位和128位，后者更普遍加密算法的安全性不在加密算法，而在于秘钥，只有有了秘钥，才能解密数据。 优缺点： 优点：加密效率高， 缺点：秘钥不适合在网上传输，不安全 缺点：秘钥维护不方便，如果某台服务器与其他多台服务器进行数据加密，需要维护多个秘钥 3-2、非对称加密 加密和解密秘钥不用，分为公钥和私钥公钥加密私钥解密私钥加密和公钥解密根据公钥推到不出私钥，根据私钥推到不出公钥 优缺点： 缺点：加密效率低 优点：维护简单，每台电脑只需要维护一个秘钥对。 与对称加密的结合使用： 数据使用对称加密。将对称加密的秘钥进行非对称加密 解密的时候，需要用私钥对对称秘钥进行解密，解出的秘钥进行对称解密。 4、数字签名 作用：防止抵赖，能够检查签名后内容是否被更改 实现： A有公钥和私钥，对合同使用单向散列函数进行处理，得到一个128位的摘要，可以理解为文件的指纹。 A利用私钥对摘要进行加密，得到A的签名，A将A的公钥、签名、文件一起传给B B利用单向三列函数对合同进行处理，得到128位摘要，利用公钥把签名进行解密，看两个摘要是否相同。 应用场景： 公司老板下发放假通知， 政府下发各种指示 文件不害怕被别人看，只需要保证不被别人篡改。 5、证书颁发机构CACA的作用： 为企业和用户颁发数字证书，确认这些企业和个人的身份，为请求者的公钥和私钥添加CA签名。接收端收到以后，先拿CA的公钥验证发送端得公钥是否合法，合法以后，进行数据的接收 发布证书吊销列表 企业信任颁发机构","tags":[{"name":"Computer Network","slug":"Computer-Network","permalink":"http://yoursite.com/tags/Computer-Network/"}]},{"title":"第六章、应用层","date":"2016-05-10T16:00:00.000Z","path":"2016/05/11/6-computer-network/","text":"1、应用层协议1-1、DNS服务 负责域名解析（域名解析成IP地址） 什么是域名？ 根：. 顶级域名： com、edu、net、org、gov 二级域名： baidu inhe 域名解析的过程: 浏览器请求baidu.com，chrome首先查看自身的DNS缓存 搜索操作系统自身的DNS缓存查看 读取本地的host文件 浏览器发起一个DNS系统调用（向宽带运营商请求） 4.1宽带运营商DNS服务器缓存 4.2宽带运营商发起一个迭代DNS解析请求 4.2.1向根域问你知道baidu.com的域名的IP地址是多少 4.2.2根域一看是顶级域的IP域名，于是回复，我只知道com域的DNS服务器IP地址 4.2.3运营商DNS服务器向com域的DNS服务器发出请求，你知道baidu.com的域名的IP地址是多少 4.2.4com域的DNS服务器回复，我只知道baidu.com域的IP地址（域名注册商提供） 4.2.5宽带运营商DNS服务器向baidu.com域请求，你知道baidu.com的域名的IP地址是多少，一看，真在这，将dns服务器的IP地址发送给运营商服务器，运营商服务器将IP地址缓存在操作系统中，再发送给浏览器。5.最终浏览器拿到了baidu.com的DNS服务器的IP地址 1-2、DHCP服务 动态主机分配（就是逆向的ARP协议） DHCP客户端请求IP地址的过程 子网内广播请求，目标IP255.255.255.255，目标MAC为全F 交换机将请求转发给所有端口 DNCP服务器接收到请求，从资源池中选取某一IP，分配给客户端 跨网段地址分配 为DHCP配置多个作用域 因为广播地址不能跨路由器，所以需要给路由器添加一条路由，在收到请求后，将数据包转发给DHCP服务器所在的服务器 1-3、FTP协议 文件传输协议，利用TCP的21端口 FTP连接方式： 控制连接：标准端口21，用于发送FTP命令信息 数据连接：标准端口20，用于上传、下载数据 数据连接的建立类型： 主动模式：服务器从20端口主动向客户端发送连接 被动模式：服务器在指定范围内的某个端口被动的等待客户端发起连接 FTP传输模式： 文本模式：ASCII模式，以文本序列传输数据 二进制模式：以二进制序列传输数据 1-4、Telnet协议 远程终端协议 远程控制路由器、服务器，使用的就是telnet协议telnet + IP远程登录服务器 1-5、RDP协议 远程终端协议，远程操控计算机，与4不同的是，该远程操控是图形界面的。 1-6、HTTP协议 超文本传输协议www，万维网提供分布式服务。 1-7、电子邮件（SMTP、POP3，IMAP） SMTP用来发电子邮件POP3，IMAP用来接收电子邮件","tags":[{"name":"Computer Network","slug":"Computer-Network","permalink":"http://yoursite.com/tags/Computer-Network/"}]},{"title":"第五章、传输层","date":"2016-05-09T16:00:00.000Z","path":"2016/05/10/5-computer-network/","text":"1、传输层简介1-1、传输层功能 为相互通信的应用进程提供了逻辑通信网络层提供主机之间的逻辑通信 1-2、TCP、UDP简介 TCP：传输的文件较大，需要对文件进行分段，建立会话，可靠传输，可以实现流量控制 UDP：一个数据包就能够完成数据通信，不需要分段，不需要建立会话，不可靠传输，不需要流量控制 域名解析就是典型的UDP协议，QQ聊天就是UDP。QQ传文件是TCP，邮件为TCP，FTP为TCP。（前面讲到的视频讲课，所有的学生都能看到老师的视频，老师的数据通过广播在网上发，实际使用的是UDP） 1-3、传输层协议与应用层协议之间的关系 TCP/UDP + 端口号，就是应用层协议http协议=TCP+80端口，https=TCP+443，RDP（远程桌面）=TCP+3389，ftp=TCP+21，共享文件夹=TCP+445，SMTP=TCP+25，POP3=TCP+110，Telnet=TCP+23，DNS=UDP+53 1-4、服务和应用层协议之间的关系 服务使用TCP或UDP的端口侦听客户端请求客户端使用IP地址定位服务器，使用端口号定位服务可以在服务器网卡上设置，只开放特定端口号，实现服务器网络安全 2、UDP2-1、UDP主要特点 无连接 不保证可靠 面向报文，无拥塞控制，很适合多媒体通信要求 支持一对一、一对多、多对一和多对多交互 首部开销小，只有8字节 2-2、UDP首部 首部只有8个字节，伪首部是从网络层拿到的信息，主要为了计算检验和 长度是首部+数据总长度 检验和的计算方法如下： 3、TCP3-1、TCP特点 面向连接 只能一对一 可靠传输 全双工 面向字节流 3-2、TCP 首部格式 序号：每段数据的第一个字节是整个数据的第几个字节 确认号：需要发送的下一个数据段的首字节号 数据偏移：首部中的一个1代表4个字节，数据偏移代表TCP首部一共有多长 URG：紧急标志位，标记为1后，在缓存里不排队，直接传递 ACK：为1时，确认号才有效，为0时确认号无效 PSH：接收到数据时，不需要排队 RST：为1代表会话出错，需要重新建立连接（打开浏览器时，点了×） SYN：同步的时候，SYN为1，SYN攻击，发送多个建立TCP连接的无效报文 FIN：断开连接时使用 窗口：建立连接时，相互告诉对方各自的窗口大小，以及接收的最大数据包大小 校验和：（和UDP一样，需要添加伪首部） 紧急指针：URG为1时，该字段才起作用，表示紧急数据结束的位置 3-3、TCP可靠传输 超时重发 停止等待协议：优点简单，缺点信道利用率低 流水线传输：发送方连续发送多个分组，不必每发完一个分组就停顿下来等待对方确认。 滑动窗口实现可靠传输：TCP没发送一个报文，就对这个报文设置一个计时器，只要计时器设置的重传时间到，但是还没有收到确认，就要重传这一段报文 3-4、TCP流量控制 接收端处理数据不及时，给发送端回复中，调小发送窗口，实现流量控制 3-5、TCP拥塞避免 1. 拥塞控制所起的作用： 2. 慢开始和拥塞避免 发送方维持拥塞窗口cwnd，只要网络没有拥塞，cwnd就会增加一些，只要网络出现拥塞，cwnd就会减小一些。 慢开始的原理如图所示 慢开始和拥塞避免算法如下：当出现网络拥塞的时候，慢开始门限更新为当前拥塞窗口（cwnd）的一半。 3.快重传算法 正常情况下，发送n个数据包，接收端给个确认信号，让发送端接着发送第n+1个数据包。如果第k个数据包丢了，接收端发现以后，立刻给发送端回复3个确认信息，让其重传k，而不是等到n个数据包接收到以后再重传。 4.快恢复算法 当发送端接收到连续3个相同的确认信号时，执行拥塞避免算法，从新的慢开始门限处的发送窗口大小，进行快恢复。 5.发送窗口的实际大小 发送窗口的上限值= Min(rwnd, cwnd)，其中rwnd是接收端的接收窗口大小 3-6、TCP连接管理 3-6-1、TCP连接建立过程 3-6-2、TCP连接断开过程","tags":[{"name":"Computer Network","slug":"Computer-Network","permalink":"http://yoursite.com/tags/Computer-Network/"}]},{"title":"第四章、网络层","date":"2016-05-08T16:00:00.000Z","path":"2016/05/09/4-computer-network/","text":"1、数据发送过程 对于应用程序 传输层：对数据进行分段（段） 网络层：添加源、目的IP地址（包） 数据链路层：添加源、目的MAC地址（帧) 使用自己的子网掩码判断自己属于哪个网段、目标属于哪个网段如果属于同一网段：arp协议广播解析目标IP地址的MAC如果不属于同一网段：发送给路由器（网关），arp网关的MAC地址，然后把数据包发送给路由器 物理层：转化成数字信号（bit） 2、网络层协议 网络层协议分层，ARP协议为IP协议服务，IP协议为ICMP协议和IGMP协议服务。 2-1、ARP协议 将IP地址通过广播，目标MAC地址为全F，获取IP地址的MAC地址。广播不能跨路由。ARP网络欺骗：（网络执法官软件，可以规定任意两台计算机通或者不通），当计算机ARP广播的时候，网络执法官回复一个不存在的MAC地址。这样发送端发送的数据包全部被交换机丢弃掉了 2-2、ICMP协议 ping命令使用ICMP协议，ping可以查看时延，TTL表示生存周期，没过一个路由器，TTL减1ping 8.8.8.8 -i 2 通过更改数据包TTL时间，能够跟踪数据包途径的路由器，（通过查看数据包返回的IP地址） Linux TTL=64 Windows TTL=128 Unix TTL=255 2-3、IGMP协议 点到点：好处，播放流媒体可以快进快退 广播：视频讲课，老师控制计算机，实验室每个学生可以看到同样的内容。（好处，不用发送多份数据，只需要发送一份数据即可） 组播=多播：（同一服务器，播放不同课程，），对服务器绑定多个多播IP地址，接收端设置不同的多播IP，就能接收到不同的数据。（缺点，不能调解视频的播放速率。可以用电视频道来理解多播） 2-4、IP协议 所有能够选路的协议都是IP协议 2-4-1、RIP协议 路由器均配置为RIP协议，周期性在广播路由表，即自己所连得网段信息(RIP协议选取跳数最少的连接)，30s更新一次，广播最大的跳数为15 2-4-2、OSPF协议 选路的标准是带宽，而不是最少跳数。 3、IP数据包格式（IP协议） IP数据包由首部和数据部分组成，首部分为固定部分和可变部分，固定部分有20个字节。 版本：4位，TCP/IP版本号 v4/v6 首部长度：4位，首部一共多长，因为有可变部分，所以有该字段 总长度：2个字节，表示整个IP数据包的总大小（因为数据链路层IP数据包最大是1500字节，所以IP数据包&gt;1500字节时，需要进行分片，才能被数据链路层接收） 标识：2个字节，数据包分片以后的标识 标志：数据包是否分片的标志位，占3位，目前只有两位有意义，最后一位MF=0，表示最后一个分片，MF=1表示后面还有分片。中间位DF=0是允许分片，DF=1时不允许分片。 片偏移：13位 生存时间：1个字节，TTL，没过一个路由器，MAC地址要修改，TTL要减1 协议：数据是什么协议ICMP（1）、IGMP（2）、TCP（6）、UDP（17）、IPv6（41）、OSPF（89） 首部检验和：检验首部是否有错，数据包检验过程如下：","tags":[{"name":"Computer Network","slug":"Computer-Network","permalink":"http://yoursite.com/tags/Computer-Network/"}]},{"title":"第三章、数据链路层","date":"2016-05-07T16:00:00.000Z","path":"2016/05/08/3-computer-network/","text":"1、数据链路层解决的三个基本问题1-1、封装成帧 数据包添加帧头、帧尾、物理层MAC地址、校验值，就构成了帧 1-2、透明传输 帧的格式如下： 如图所示，每个帧会有一个开始标志和结束标志 当数据中包含帧头或者帧尾字符时，如下图所示，需要添加’ESC’(对应的十六进制编码是1B)进行转义 1-3、差错控制 循环冗余检验（CRC）具体如图所示：需要传输的数据是101001，对数据添加3位0，除以4位的数（除数的位数是所添加0的位数+1），得到的余数作为FCS（帧检验序列）。接收到数据帧以后，对数据进行校验的过程就是，将FCS添加到数据末尾，除以1101，看余数是否为0。如果为0，接收，如果不为0，丢弃。该方法只能检测到错误，不能检测具体的错误位置CRC只是得到FCS的一种方法 2、两种情况下的数据链路层2-1、使用点对点通信的数据链路层 点对点通信使用PPP协议，适用于ADSL拨号上网，一般用于广域网。 2-1-1、PPP协议帧格式 标志字段F：一个字节0x7E,在帧的开始和结束 地址字段A：不起作用，置为0xFF 控制字段C：通常设为0x03 协议：标记数据包的协议类型 2-1-2、透明传输 字节填充方法 如果数据部分出现0x7E,需要将数据转换成2个字节(0x7D,0x5E) 如果信息字段中出现一个0x7D字节，需要将它转变成（0x7D,0x5D） 零比特填充方法（如果传输的信息不是整数字节，传输二进制流） 数据出现5个连续的1，末尾插入0 2-2、使用广播信道的数据链路层 一般适用于局域网，使用CSMA/CD协议 3、以太网帧格式 MAC地址由48位二进制组成，前24位代表厂家，后24位厂家具体的标志位 网络层添加18个字节，以太网的帧最小时64个字节，所以IP数据包最小是46个字节。在物理层传输时，需要插入8个字节。但不属于帧中的内容。","tags":[{"name":"Computer Network","slug":"Computer-Network","permalink":"http://yoursite.com/tags/Computer-Network/"}]},{"title":"第二章、物理层","date":"2016-05-06T16:00:00.000Z","path":"2016/05/07/2-computer-network/","text":"1、数据通信1-1、数据通信的基本模型 在同一个交换机下的两台主机通信时，是传输的数字比特流，跨路由器时，中间才会传输模拟信号。 1-2、数据通信的基本术语 通信的目的是传送消息 数据：运输消息的实体 信号：数据的电气或电磁表现 码元：一定时间间隔内的符号表示的二进制数字，就是二进制码元，1码元可以携带nbit的信息量 1-3、常用编码 单极性不归零码 双极性不归零码 单极性归零码：无法判断传输的内容是0还是没有数据 双极性归零码 曼彻斯特编码： 由低变高代表0， 由高变低为1 通过两次采样才能得到数据。携带时钟信号 差分曼彻斯特编码： bit中间有信号跳变，bit与bit之间有信号跳变，表示下一个bit为0 bit中间有信号跳变，bit与bit之间没有信号跳变，表示下一个bit为1 1-4、信道极限容量 奈氏准则：假定理想条件下，为了避免码间串扰，码元传输速率的上限值。(奈氏准则适用于模拟信号的传输) 香农公式：带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率（香农公式适用于模拟和数字信号的传输） 香农公式：C = Wlog2(1+S/N) b/s","tags":[{"name":"Computer Network","slug":"Computer-Network","permalink":"http://yoursite.com/tags/Computer-Network/"}]},{"title":"第一章、计算机网络概述","date":"2016-05-05T16:00:00.000Z","path":"2016/05/06/1-computer-network/","text":"1、局域网 局域网的网线不超过100米，百兆交换机意味着每个端口都是百兆。接入层的端口一定要多，汇聚层端口的带宽一定要大。(接入层的多个交换机以行星的模式接入汇聚层交换机) 局域网：覆盖范围小，自己花钱购买设备，带宽固定，自己单位维护（网线最长100米，带宽 10M 100M 1000M） 广域网：（ADSL拨号上网就是广域网，网线超过100米）距离比较远，超过100米，花钱买服务（租带宽），其他人服务 Internet：由运营商组成，自己的机房，对网民提供访问Internet的连接。跨运营商访问速度比较慢。（因为运营商之间是由一根网线连接的）解决方案是在网通和电信分别配置服务器，下载的时候选择运营商进行下载 2、MAC、IP、网关 网关就是，要想和其他网段通信，需要将数据发送给谁，一般路由器的端口地址就是网关地址，14.0.0.1,默认为IP的第一个地址。 计算机网卡有MAC地址，计算机有IP地址 3、数据包和帧 数据+源、目的IP地址 = 数据包（最大1500字节） 数据+源、目的IP+源、目的MAC地址 = 帧 跨路由器交互时需要重写源、目的MAC地址 MAC地址决定了下一跳给谁，IP地址决定了数据包最终给谁 4、访问网站的数据传输 服务器接收到请求，返回数据，将网页信息切割成多个数据包（因为每个数据包最大1500字节），将数据包依次加入缓存（服务器端），依次发送，（对于已经发送的数据，依然在缓存中存在，因为可能发送失败，需要重发），客户端收到后，将数据存在缓存中，给服务器端发送确认信息，要求服务器发送下一个数据包。客户端浏览器从缓存中读取数据包。 5、OSI参考模型5-1、分层结构 分层好处：每一层相互独立，相互之间不会影响（举例ip4,ipv6只是改变了网络层，其他层均没变化）层与层之间的关系：下面的层为上层提供服务，最上的应用层为人服务。 应用层：所有能够产生网络流量的程序，可以和用户交互的程序 表示层：传输之前，对数据进行加密或者压缩处理（QQ视频对图片进行压缩、加密）（主要面向开发人员）（编码） 会话层：访问网络，打开不同窗口，显示相应的内容，就是会话层实现的，同时流媒体的快进和快退也是会话层实现的（windows netstat –n查看会话列表），会话的作用是可以查看木马（远程控制木马、QQ盗号木马，其不同于病毒，病毒是用于篡改你的文件的），netstat –n就可以看出木马 传输层：实现可靠传输（TCP）、流量控制（接收方处理不过来，通知服务方，减缓发送速率）、不可靠传输（DNS解析、QQ聊天，一个数据包就能解决问题的时候用不可靠传输） 网络层：负责选择最佳路径，规划IP地址 数据链路层：定义帧的开始和结束 （定义开始和结束），透明传输（帧的开头和结尾由特殊的01字符进行标识，如果数据中，有的数据和结束位相同，发送数据的时候，要在数据（与帧结尾的标识相同的字段）前面添加标识符，交换机接收到数据时，对数据进行解析，删除标识符），差错校验 物理层：定义网络设备的接口标准（网卡8根线），电器标准（数据的0,1由电压表示），如何在物理链路上传输更快的速度 5-2、OSI参考模型网络排错 每一层都要为上一层服务，所以网络出现问题时，要自下往上进行排错。网线有8根线，两根负责发送，两根负责接收 物理故障查看网络连接状态 发送接收的数据包 数据链路层故障 MAC地址冲突（连接同一交换机的时候）（可以自己注册MAC地址）ADSL拨号欠费，数据链路层故障。网速无法协商一致（网卡网速和交换机端口网速协商）。计算机连接到错误的VLAN 网络层（规划地址，选择链路）故障。配置错误的IP地址 子网掩码。没有配置网关，或者配置了错误的网关，无法访问外网，也就无法实现选路。路由器没有配置到达目标网络的路由。 应用层故障（网络层以上统称为应用层故障）。 5-3、OSI参考模型网络安全 物理层安全：不要让别人随便接入自己的交换机，将交换机上多余的网线拔掉或者用命令关闭某个交换机端口 数据链路层安全：ADSL账号密码。划分VLAN。交换机端口绑定MAC地址。 网络层安全：路由器基于IP地址实现流量控制（使用ACL控制数据包流量） 应用层安全（网络层以上）：开发的应用程序没有漏洞 6、计算机性能指标 速率：一对连接双方在物理层传输速度 带宽：数字信道传输的最大速率 吞吐量：单位时间通过网络的数据量（速率5M，速率10M，带宽100M，吞吐量15M） 时延：（包括发送、传播、处理、排队时延） 发送时延：数据包从网卡发出的时延 传播时延：链路中传输的时延 处理时延：路由器寻址时延 排队时延：路由器交换机数据包排队时延 时延带宽积 = 时延X带宽（链路上bit数量） 往返时间RTT（ping） 利用率：D = D0/(1-U)其中D0指空闲时的时延，D是指网络当前时延，U就是信道利用率。U = 1-D0/D","tags":[{"name":"Computer Network","slug":"Computer-Network","permalink":"http://yoursite.com/tags/Computer-Network/"}]},{"title":"LeetCode-344","date":"2016-04-30T07:46:17.000Z","path":"2016/04/30/LeetCode-344/","text":"","tags":[]},{"title":"LeetCode-191","date":"2016-04-30T07:46:12.000Z","path":"2016/04/30/LeetCode-191/","text":"","tags":[]},{"title":"LeetCode-179","date":"2016-04-30T07:46:08.000Z","path":"2016/04/30/LeetCode-179/","text":"","tags":[]},{"title":"LeetCode-89-Gray Code","date":"2016-04-29T15:13:14.000Z","path":"2016/04/29/LeetCode-89/","text":"题目 对于n位的二进制，返回n位二进制的所有数字，集合保证相邻的二进制数只有1bit不同 分析 举例说明：输入：n=2输出： 00 - 0 01 - 1 11 - 3 10 - 2 所以返回[0,1,3,2]从n=0开始，逐步写，可以看出规律，下面的数字除了第一位不同，其余与上面的呈镜像关系，所以在得到上面的结果后，只需要将上面的数字第一位换成1，反向插入即可。 C++代码实现12345678910111213141516class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; if(n == 0)&#123; vector&lt;int&gt; res; res.push_back(0); return res; &#125; vector&lt;int&gt; pre_res = grayCode(n-1); vector&lt;int&gt; cur_res(pre_res); for(int i = pre_res.size()-1; i &gt;= 0; i--)&#123; cur_res.push_back(cur_res[i] + (1 &lt;&lt; (n-1))); &#125; return cur_res; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"LeetCode-88-Merge Sorted Array","date":"2016-04-29T15:13:11.000Z","path":"2016/04/29/LeetCode-88/","text":"题目 合并两个排好续的数组，使得合并后的数组仍是排好续的，其中数组num1，存储的数据为m个，num2存储n个，num1的存储空间大于m+n,返回合并后结果num1 分析 对于num1和num2从最后一个数开始比较，依次存放到num1的最后面（起始地址是m+n-1） C++代码实现12345678910111213141516class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int i = m - 1; int j = n - 1; int k = m + n -1; while(i &gt;= 0 &amp;&amp; j &gt;= 0)&#123; if(nums1[i] &lt; nums2[j]) nums1[k--] = nums2[j--]; else nums1[k--] = nums1[i--]; &#125; while(j &gt;= 0) nums1[k--] = nums2[j--]; &#125;&#125;;","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-86-Partition List","date":"2016-04-29T15:13:08.000Z","path":"2016/04/29/LeetCode-86/","text":"题目 给定一个链表，给定一个target，讲链表中小于target的元素移至链表的前面，保持其余元素的相对位置不变 分析 举例分析：输入：1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5构建两个链表，链表1存储小于target的元素，链表2存储大于target的元素，最后将两个链表拼接 C++代码实现123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; if(!head || !head-&gt;next) return head; ListNode *p1, *p2; ListNode tmp1(-1), tmp2(-1); p1 = &amp;tmp1, p2 = &amp;tmp2; while(head) &#123; if(head-&gt;val &lt; x)&#123; p1-&gt;next = head; p1 = p1-&gt;next; &#125; else &#123; p2-&gt;next = head; p2 = p2-&gt;next; &#125; head = head-&gt;next; &#125; p2-&gt;next = NULL; p1-&gt;next = tmp2.next; return tmp1.next; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode-83-Remove Duplicates from Sorted List","date":"2016-04-29T15:12:53.000Z","path":"2016/04/29/LeetCode-83/","text":"题目 给定排好续的链表，将重复的元素变为单一元素，返回链表 分析 举例分析：输入： 1-2-3-3-4-4-5返回： 1-2-3-4-5 C++代码实现123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode *res; ListNode tmp(-1); res = &amp;tmp; ListNode *pre = res; while(head)&#123; while(head-&gt;next &amp;&amp; head-&gt;next-&gt;val == head-&gt;val) head = head-&gt;next; pre-&gt;next = head; head = head-&gt;next; pre = pre-&gt;next; &#125; return res-&gt;next; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode-82-Remove Duplicates from Sorted List II","date":"2016-04-29T15:12:50.000Z","path":"2016/04/29/LeetCode-82/","text":"题目 给定一个排好续的链表，删除链表中重复的元素 分析 举例说明：输入： 1-2-3-3-4-4-5返回： 1-2-5考虑特殊情况1-1-1,1-2-2,1-2-2-3,1-2-2-3-3 C++代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode * res; ListNode first(0); res = &amp;first; res-&gt;next = head; ListNode *pre = res; ListNode *cur = head; bool dup = false; while(cur != NULL) &#123; while(cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;val == cur-&gt;val) &#123; cur = cur-&gt;next; dup = true; &#125; if(dup &amp;&amp; cur-&gt;next == NULL) //针对&#123;1,1,2,2&#125;&#123;1,1&#125;的情况 &#123; pre-&gt;next = cur-&gt;next; pre = pre-&gt;next; &#125; if(!dup) &#123; pre-&gt;next = cur; pre = pre-&gt;next; &#125; dup = false; cur = cur-&gt;next; &#125; return res-&gt;next; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode-81-Search in Rotated Sorted Array II","date":"2016-04-29T15:12:48.000Z","path":"2016/04/29/LeetCode-81/","text":"题目 对于一个旋转后的有序数组，返回数组中是否存在target 分析 排好续的数组旋转，即[1,2,3,4,5]变为[4,5,1,2,3]可以看出，旋转后，变为两段升序的数组所以利用二分查找时，通过确定mid和left的关系，就能确定mid隶属于那一段数组中 C++代码实现12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size() - 1; if(r &lt; 0) return false; while(l &lt;= r) &#123; int m = l + (r - l)/2; if(nums[m] == target) return true; if(nums[l] &lt; nums[m]) //mid左边升为序数组 &#123; if(nums[m] &gt; target &amp;&amp; nums[l] &lt;= target) r = m - 1; else l = m + 1; &#125; else if(nums[l] &gt; nums[m]) //mid右边数升序数组 &#123; if(nums[m] &lt; target &amp;&amp; nums[r] &gt;= target) l = m + 1; else r = m - 1; &#125; else l++; &#125; return false; &#125;&#125;;","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-80-Remove Duplicates from Sorted Array II","date":"2016-04-29T15:12:45.000Z","path":"2016/04/29/LeetCode-80/","text":"题目 给定排好续的数组，删除重复的元素，保证每个元素最多出现2次，返回去重后数组的大小，并且保证数组的前k个数是去重以后的结果。 分析 举例分析：对于[1,1,1,2,2,3]应该返回[1,1,2,2,3]因为是排好续的数组，所以只需要比较某一为与他的前两位是否相等，如果相等，覆盖该位。 C++代码实现1234567891011121314151617181920class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt;= 2) return nums.size(); int res = 2; for(int i = 2; i &lt; nums.size(); i++)&#123; if(nums[i] != nums[res-2]) nums[res++] = nums[i]; &#125; return res; &#125;&#125;;// int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;// int i = 0;// for (int n : nums)// if (i &lt; 2 || n &gt; nums[i-2])// nums[i++] = n;// return i;// &#125;","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-79-Word Search","date":"2016-04-29T15:12:41.000Z","path":"2016/04/29/LeetCode-79/","text":"题目 给定二维字符数组，寻找数组中是否存在某个单词。要求该word在数组中的位置是连续的。且位置不能重复。注：只能上下左右遍历字符。 分析 举例分析：对于： [[‘A’,’B’,’C’,’E’],[‘S’,’F’,’C’,’S’],[‘A’,’D’,’E’,’E’]] word = “ABCCED”, -&gt; returns true, word = “SEE”, -&gt; returns true, word = “ABCB”, -&gt; returns false. 显然利用DFS进行遍历。对于遍历过的数据进行标记。 C++代码实现12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt; &gt;&amp; board, string word) &#123; int rows = board.size(); int cols = board[0].size(); for(int i = 0; i &lt; rows; i++)&#123; for(int j = 0; j &lt; cols; j++)&#123; if(isFound(board, word, 0, i, j)) return true; &#125; &#125; return false; &#125;//函数形参board使用引用，如果使用简单的赋值会超时。引用只是简单的赋值了 bool isFound(vector&lt;vector&lt;char&gt; &gt; &amp;board, string word, int len, int i, int j)&#123; if(i &lt; 0 || i &gt;= board.size() || j &lt; 0 || j &gt;= board[0].size() || board[i][j] == '\\0' || word[len] != board[i][j] || len &gt;= word.length()) return false; if(len == word.length() - 1 &amp;&amp; word[len] == board[i][j]) return true; char tmp = board[i][j]; board[i][j] = '\\0'; if( isFound(board, word, len+1, i, j+1) || isFound(board, word, len+1, i+1, j) || \\ isFound(board, word, len+1, i-1, j) || isFound(board, word, len+1, i, j-1)) return true; else &#123; board[i][j] = tmp; return false; &#125; &#125;&#125;;","tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-75-Sort Colors","date":"2016-04-15T11:39:17.000Z","path":"2016/04/15/LeetCode-75/","text":"题目 对红黄蓝三种颜色进行排序，按照红黄蓝的顺序排列，现在红-0，黄-1，蓝-2表示，对该数组进行排序，注：不能借助排序函数实现 分析 显然，如果追求空间复杂度，一定会是原地排序实现 首先设置首尾指针 遍历数组，由于只有三个元素，所以，如果数据==2，该元素与尾指针交换，尾指针–，如果该元素==0，则与首指针交换，对于1不做处理 边界条件while(nums[i] == 2 &amp;&amp; i &lt; right)和while(nums[i] == 0 &amp;&amp; i &gt; left) C++代码实现12345678910class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int left = 0, right = nums.size()-1; for(int i = 0; i &lt;= right; i++)&#123; while(nums[i] == 2 &amp;&amp; i &lt; right) swap(nums[i], nums[right--]); while(nums[i] == 0 &amp;&amp; left &lt; i) swap(nums[i], nums[left++]); &#125; &#125;&#125;;","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-78-Subsets","date":"2016-04-15T09:57:48.000Z","path":"2016/04/15/LeetCode-78/","text":"题目 给定一个数组，输出数组中元素所有可能的组合数 分析 距离说明：输入：[1,2,3]输出：[ &nbsp;&nbsp;[3], &nbsp;&nbsp;[1], &nbsp;&nbsp;[2], &nbsp;&nbsp;[1,2,3], &nbsp;&nbsp;[1,3], &nbsp;&nbsp;[2,3], &nbsp;&nbsp;[1,2], &nbsp;&nbsp;[]] C++代码实现123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; getsubsets(res, tmp, nums, 0); return res; &#125; void getsubsets(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;tmp, vector&lt;int&gt; nums, int start)&#123; res.push_back(tmp); for(int i = start; i &lt; nums.size(); i++)&#123; tmp.push_back(nums[i]); getsubsets(res, tmp, nums, i+1); tmp.pop_back(); &#125; &#125;&#125;;","tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-77-Combinations","date":"2016-04-15T09:45:36.000Z","path":"2016/04/15/LeetCode-77/","text":"题目 给定n,k，输出Cnk的所有组合数 分析 显然利用dfs进行遍历 C++代码实现12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; dfs(res, tmp, 1, k, n); return res; &#125; //C++函数的引用传递,res为引用传递，tmp为值传递 void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; tmp, int start, int k, int n)&#123; if(tmp.size() == k) &#123; res.push_back(tmp);//与java不同，不需要新建vector对象。 return; &#125; for(int i = start; i &lt;= n; i++)&#123; tmp.push_back(i); combine_func(res,tmp, i + 1, k, n); tmp.pop_back(); &#125; &#125;&#125;;","tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-74-Search a 2D Matrix","date":"2016-04-05T10:37:45.000Z","path":"2016/04/05/LeetCode-74/","text":"题目 给定二维矩阵，二维矩阵满足每一行是递增的没一列的第一位大于上一列的最后一维 分析 首先定位，该问题属于查找问题 通过二位矩阵数据可以看出，数据是有序的，首先想到的是二分查找 由于二分查找是针对一维数据而言，所以首先对数据转化成一维，进而进行二分查找。 C++代码实现123456789101112131415class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int rows = matrix.size(); int cols = matrix[0].size(); int num = rows * cols; int left = 0, right = num-1; while(left &lt; right)&#123; int mid = (left + right) &gt;&gt; 1; if(matrix[mid/cols][mid%cols] &lt; target) left = mid + 1; else right = mid; &#125; return matrix[right/cols][right%cols] == target; &#125;&#125;;","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-73-Set Matrix Zeroes","date":"2016-04-03T16:00:00.000Z","path":"2016/04/04/LeetCode-73/","text":"题目 对于二维数组，如果某一位为0，则该位所在的行和列都变为0 分析 对于第一列，做特殊标记，如果第一列中包含0元素，那么标记一下，第一列最后全为0遍历除第一列以外的所有元素，如果某元素为0，则设置matrix[i][0]=matrix[0][j]=0从后往前遍历，如果matrix[i][0]=0 || =matrix[0][j]=0,该元素设为0如果第一列的标志位为0，则matrix[i][0] = 0 C++代码实现12345678910111213141516171819202122232425class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int col0 = 0; //记录第一列是否有为0的元素 int len_rows = matrix.size(); int len_cols = matrix[0].size(); for(int i = 0; i &lt; len_rows; i++)&#123; if(matrix[i][0] == 0) col0 = 1; for(int j = 1; j &lt; len_cols; j++)&#123; if(matrix[i][j] == 0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; for(int i = len_rows - 1; i &gt;= 0; i--)&#123; for(int j = len_cols - 1; j &gt;= 1; j--)&#123; if(matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0; &#125; if(col0 == 1) matrix[i][0] = 0; &#125; &#125;&#125;;","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-70-Climbing Stairs","date":"2016-04-02T19:50:20.000Z","path":"2016/04/03/LeetCode-70/","text":"题目 爬梯子，梯子共有n阶，每次你可以攀登1阶或者2阶，从梯子底端爬至顶端，会有多少种不同的方案 分析 递归实现，最后一步一定是走了1阶或者两阶，所以f(n) = f(n-1)+f(n-2)注:直接调用递归会超时 C++代码实现1234567891011121314151617class Solution &#123;public: int climbStairs(int n) &#123; if(n &lt;= 2) return n; else return res(n); &#125; int res(int n)&#123; int a[n+1]; a[1] = 1; a[2] = 2; for(int i = 3; i &lt;= n; i++) a[i] = a[i-2] + a[i-1]; return a[n]; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/递归/"}]},{"title":"LeetCode-71-Simplify Path","date":"2016-04-02T16:00:00.000Z","path":"2016/04/03/LeetCode-71/","text":"题目 简化linux目录结构 分析 举例说明path = “/home/“, =&gt; “/home”path = “/a/./b/../../c/“, =&gt; “/c” C++代码实现1234567891011121314151617class Solution &#123;public: string simplifyPath(string path) &#123; string res, tmp; vector&lt;string&gt; a; stringstream ss(path); while(getline(ss, tmp, '/'))&#123; //分割字符串 if(tmp == \".\" || tmp == \"\" || (a.empty() &amp;&amp; tmp == \"..\")) continue; //特殊情况\"///\"和\"/..\" if(tmp == \"..\" &amp;&amp; !a.empty()) a.pop_back(); //需要考虑a是否为空 else a.push_back(tmp); &#125; for(string str:a)&#123; res += \"/\"+str; &#125; return res==\"\" ? \"/\":res; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"LeetCode-69-Sqrt(x)","date":"2016-04-01T16:00:00.000Z","path":"2016/04/02/LeetCode-69/","text":"题目 求解Sqrt(x)返回整数结果 分析 方法一利用二分查找，否则会超时方法二牛顿迭代公式，此方法可以返回相对精准的double结果 C++代码实现12345678910111213141516171819202122//方法一、二分查找class Solution &#123;public: int mySqrt(int x) &#123; if(x == 0) return 0; int e = x / 2 + 1; int s = 1; while(s &lt;= e)&#123; //防止s+e越界，所以使用此公式求解中间值 int mid = s + (e-s)/2; long long sq = (long long)mid * (long long)mid; if(sq == x) return mid; if(sq &lt; x) s = mid + 1; else e = mid - 1; &#125; return e; &#125;&#125;;//方法二、牛顿迭代公式","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"LeetCode-67- Add Binary","date":"2016-04-01T16:00:00.000Z","path":"2016/04/02/LeetCode-67/","text":"题目 二进制数字相加，返回二进制字符串 分析 举例说明：输入”11”,”1”,返回”100” C++代码实现1234567891011121314151617181920212223class Solution&#123;public: string addBinary(string a, string b) &#123; string res = \"\"; int len_a = a.length(); int len_b = b.length(); int carry = 0; while(len_a &gt; 0 || len_b &gt; 0)&#123; //从后往前依次相加，因为数字的低位在字符串的高位存储 int abit = len_a &gt; 0 ? a[len_a-1] - '0' : 0; int bbit = len_b &gt; 0 ? b[len_b-1] - '0' : 0; int cbit = carry &gt; 0 ? 1 : 0; //字符串存在insert函数，可以直接调用 res.insert(res.begin(), '0' + ((abit + bbit + cbit) &amp; 1)); carry = (abit + bbit + cbit) / 2; len_a--; len_b--; &#125; if(carry &gt; 0) res.insert(res.begin(), '0' + carry); return res; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"LeetCode-66-Plus One","date":"2016-04-01T16:00:00.000Z","path":"2016/04/02/LeetCode-66/","text":"题目 将一个数字按list记性存储，对这个数字+1，结果按list形式返回 分析 涉及简单的进位问题，设置进位标志项即可实现。 C++代码实现1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; vector&lt;int&gt; res; int x = 1; while(digits.size()!=0)&#123; int y = digits.back(); digits.pop_back(); x = x + y; res.insert(res.begin(), x % 10); x = x /10; &#125; if(x != 0) res.insert(res.begin(), x); return res; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"LeetCode-64-Minimum Path Sum","date":"2016-04-01T16:00:00.000Z","path":"2016/04/02/LeetCode-64/","text":"题目 给定m*n矩阵。存储当下节点的权重，求解从左上角到达右下角，所经过的路径的最小权重 分析 DP思想实现，dp[i][j]存储从[0][0]到达[i][j]所经历的路径的最小权重和具体思路见代码注释处 C++代码实现1234567891011121314151617181920212223242526272829303132/**Use DP* dp[i][j] from [0][0] to [i][j], The min sum of all numbers along this path.* dp[i][j] = grid[i][j] if i == 0 &amp;&amp; j == 0* = grid[i][j-1] + grid[i][j] if j == 0 &amp;&amp; i != 0* = grid[i-1][j] + grid[i][j] if i == 0 &amp;&amp; j != 0* = min(dp[i-1][j] + dp[i][j-1]) + grid[i][j] if i != 0 &amp;&amp; j != 0*/class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;vector&lt;int&gt;&gt; res = grid; int min_num = 0; for(int i = 0; i &lt; grid.size(); i++)&#123; for(int j = 0; j &lt; grid[i].size(); j++)&#123; if(i == 0 &amp;&amp; j == 0)&#123; min_num = res[i][j] = grid[i][j]; &#125; else if(i == 0)&#123; min_num = res[i][j] = res[i][j-1] + grid[i][j]; &#125; else if(j == 0)&#123; min_num = res[i][j] = res[i-1][j] + grid[i][j]; &#125; else&#123; min_num = res[i][j] = min(res[i-1][j], res[i][j-1]) + grid[i][j]; &#125; &#125; &#125; return min_num; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-63-Unique Paths II","date":"2016-03-31T16:00:00.000Z","path":"2016/04/01/LeetCode-63/","text":"题目 mn的矩阵，从左上角走到右下角，所有的路径一共有多少(中间存在障碍，给定的二维矩阵，1代表障碍，0代表通畅)*注：每次只能走一步，只能向右或向下走 分析 举例说明：对于[ [0,0,0], [0,1,0], [0,0,0]]输出结果为2DP实现,dp[i][j]代表[0][0]到[i][j]所经历的路径的数目详解见代码注释 C++代码实现1234567891011121314151617181920212223242526272829303132/**Use DP to realize it*dp[i][j] is the max num of ways from [0][0] to [i][j]*dp[i][j] = 0 if obstacleGrid[i][j] == 1 * = dp[i-1][j] + dp[i][j-1] i &gt; 0 &amp;&amp; j &gt; 0 &amp;&amp; obstacleGrid[i][j] != 1 * = dp[i-1][j] i &gt; 0 &amp;&amp; j == 0 &amp;&amp; j &gt; 0 &amp;&amp; obstacleGrid[i][j] != 1 * = dp[i][j-1] i == 0 &amp;&amp; j &gt; 0 &amp;&amp; j &gt; 0 &amp;&amp; obstacleGrid[i][j] != 1 * = 1 if i==0 &amp;&amp; j == 0 &amp;&amp; j &gt; 0 &amp;&amp; obstacleGrid[i][j] != 1 */class Solution&#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; vector&lt;vector&lt;int&gt;&gt; res = obstacleGrid; int num = 0; for(int i = 0; i &lt; obstacleGrid.size(); i++)&#123; for(int j = 0; j &lt; obstacleGrid[i].size(); j++)&#123; if(obstacleGrid[i][j] == 1) num = res[i][j] = 0; else&#123; if(i &gt; 0 &amp;&amp; j &gt; 0) num = res[i][j] = res[i-1][j] + res[i][j-1]; else if(i &gt; 0) num = res[i][j] = res[i-1][j]; else if(j &gt; 0) num = res[i][j] = res[i][j-1]; else num = res[i][j] = 1; &#125; &#125; &#125; return num; &#125;&#125;;","tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-62-Unique Paths","date":"2016-03-31T16:00:00.000Z","path":"2016/04/01/LeetCode-62/","text":"题目 mn的矩阵，从左上角走到右下角，所有的路径一共有多少*注：每次只能走一步，只能向右或向下走 分析 从右上角走到左下角，一定向右走了m-1步，向下走了n-1步，所以最终的结果就是他们的排列租户方案一 (m-1+n-1)!/((m-1)!*(n-1)!)方案二 DP，dp[i][j]存储从[0][0]到[i][j]路径的数目那么：详解见代码注释 C++代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/**方法一*Finally he moves to right for m-1 steps*And move to below for n-1 steps*result = (m-1+n-1)!/((m-1)!*(n-1)!)*/class Solution &#123; public: int uniquePaths(int m, int n) &#123; if(m == 1 || n == 1) return 1; else&#123; int x = m - 1; int y = n - 1; double res = 1; for(int i = 1; i &lt;= x; i++)&#123; res *= (double)(y + i) / (double)i; &#125; return (int)(res + 0.1); // For specific case &#125; &#125;&#125;;/**方法二*Use DP to realize it*dp[i][j] is the max num of ways from [0][0] to [i][j]*dp[i][j] = 1 if i==0 || j == 0* = dp[i-1][j] + dp[i][j-1]*/class Solution &#123; public: int uniquePaths(int m, int n) &#123; int dp[m][n]; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i == 0 || j == 0) dp[i][j] = 1; else dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;;","tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-61-Rotate List","date":"2016-03-31T16:00:00.000Z","path":"2016/04/01/LeetCode-61/","text":"题目 链表右移 分析 对于给定的链表，右移k位举例说明：输入1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,输出4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.解析：右移k位，即返回以(len(list) - k%len(list))开始，以他的前一位结束的链表 C++代码实现123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(!head || k == 0) return head; // Find the length of head int len = 1; ListNode* p = head; while(p-&gt;next != NULL)&#123; len++; p = p-&gt;next; &#125; p-&gt;next = head; // To be a ring int x = len - k % len; //Very import. For the case that k&gt;len for(int i = 0; i &lt; x; i++)&#123; p = p-&gt;next; &#125; head = p-&gt;next; p-&gt;next = NULL; return head; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"Leetcode-60-Permutation Sequence","date":"2016-03-31T16:00:00.000Z","path":"2016/04/01/LeetCode-60/","text":"题目 给出n，k，求1-n的全排列中，第k个是什么 分析 全排列共有n!个，对于第k个第一位依次是1-n，每个数字引领的组合共有(n-1)!个第一位确定后，第二位依次是删除第一位数字后，剩余数字依次排开的，每个数字引领(n-2)!个依次类推，最后得出结果 C++代码实现12345678910111213141516171819202122232425class Solution &#123;public: string getPermutation(int n, int k) &#123; stringstream str; //stringstream可以吞入不同的数据类型，根据输出的元素类型，进行相应的输出(&lt;&lt; 输入，&gt;&gt; 输出) //例如 string ss; res &gt;&gt; ss;则输出字符串类型 string res; int sum = 1; vector&lt;int&gt; num; for(int i = 1; i &lt;= n; i++)&#123; sum *= i; num.push_back(i); &#125; while(n &gt; 0)&#123; sum = sum / n; //每一组有多少个元素 int x = (k -1) / sum; //很重要，第k个数在在第几组 k -= x * sum; str &lt;&lt; num[x]; num.erase(num.begin() + x); n--; &#125; str &gt;&gt; res; return res; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"Shell部分基础","date":"2016-03-27T16:15:33.000Z","path":"2016/03/28/shell/","text":"1-1、删除变量 1unset name 1-2、shell字符串 单引号：原样输出，不能有变量 双引号可以有变量 12345#获取字符串长度str=\"abcdefg\"echo $&#123;#str&#125; 7echo $&#123;str:1:4&#125; 输出bcdeecho `expr index \"$str\" a` 输出1，a在字符串str中的位置 1-3、shell数组 12345#定义数组a=(1 2 3)echo $&#123;a[@]&#125;输出a中所有的元素#获取数组元素的个数echo $ 1-4、传递参数 1234567./test.sh 1 2 3$0 = test.sh$1 = 1$2 = 2$3 = 3$$ 脚本运行进程ID$# 传递到脚本的参数的个数 1-5、运算符 算数运算符 12345a=10b=100val = `expr $a + $b`\\* / + - % （expr执行）= == ！= 关系运算符 -eq 相等为true -ne 不等为true -gt 左边是否大于右边 -lt 左边是否小于右边 -ge 左边是否大于等于 -le 左边是否小鱼等于 12345678a=10b=100if [$a -eq $b]then echo \"$a -eq $b: a 等于 b\"else echo \"$a -eq $b: a 不等于 b\"fi 布尔运算符 ！非运算 -o或运算 -a与运算 逻辑运算符 &amp;&amp;与运算 [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] ||或运算 [[ $a -lt 100 || $b -gt 100 ]] 1-6、流程控制 if-else 123456789if condition1then command1elif condition2 then command2else commandNfi for循环 12345678for str in 'This is a string'do echo $strdonefor loop in 1 2 3 4 5do echo $loopdone while循环 123456int=1while(( $int&lt;=5 )) #双括号do echo $int let \"int++\"done case 1234567891011121314case 值 in模式1) command1 command2 ... commandN ;;模式2） command1 command2 ... commandN ;;esac","tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"LeetCode-43-Multiply Strings","date":"2016-03-18T02:18:59.000Z","path":"2016/03/18/LeetCode-43/","text":"题目 给定两个数字（字符串形式），返回两个数字的乘积，返回结果为字符串形式。 描述 要求：数字可能相当大，超出整型的范围，并且数字全是非负的思路： Java代码实现123456789101112131415161718192021public class Solution &#123; public String multiply(String num1, String num2) &#123; int len1 = num1.length(), len2 = num2.length(); int[] num = new int[len1 + len2]; int sum = 0; for (int i = len1 - 1; i &gt;= 0; i--) &#123; for (int j = len2 - 1; j &gt;= 0; j--) &#123; sum = (num1.charAt(i) - '0') * (num2.charAt(j) - '0') + num[i + j + 1]; //字符串中读取某个字符，选用charAt()函数 num[i + j] += sum / 10; //注意，一个是+=，一个是= num[i + j + 1] = sum % 10; &#125; &#125; StringBuffer str = new StringBuffer(); //进行字符串相加时，不会申请新的内存空间，只是在原有基础上，末尾添加，速度块。'+'号的实现，实际是申请新的内存，对字符串进行重新的存储。 for (int p : num) &#123; if (str.length() == 0 &amp;&amp; p == 0) continue; else str.append(p); &#125; return str.length() == 0 ? \"0\" : str.toString(); &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"LeetCode-40-Combination Sum II","date":"2016-03-18T02:02:06.000Z","path":"2016/03/18/LeetCode-40/","text":"题目 依旧是对于一个数组，一个目标元素target，从数组中查找所有的组合，满足组合的和位target，只是要求会有所变化。 描述 要求： 数组中所有的数是正整数 返回的结果必须按升序排列 返回的结果不能有重复 数组中的每个数字最多只能用一次 Java代码实现123456789101112131415161718192021222324//回溯法public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); getResult(res, new ArrayList&lt;Integer&gt;(), candidates, 0, target); return res; &#125; private void getResult(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp, int[] candidates, int start, int target)&#123; if(target &gt; 0)&#123; for(int i = start; i &lt; candidates.length &amp;&amp; target &gt;= candidates[i]; i++)&#123; if(i &gt; start &amp;&amp; candidates[i] == candidates[i-1]) continue; //去除重复的选择项 tmp.add(candidates[i]); getResult(res, tmp, candidates, i+1, target - candidates[i]); tmp.remove(tmp.size() - 1); &#125; &#125; else if(target == 0)&#123; res.add(new ArrayList&lt;Integer&gt;(tmp)); &#125; &#125;&#125;","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-39-Combination Sum","date":"2016-03-18T01:50:10.000Z","path":"2016/03/18/LeetCode-39/","text":"题目 对于给定的数组，目标值target，从数组中寻找组合，使得组合的和为target 描述 要求： 数组中所有的数是正整数 返回的结果必须按升序排列 返回的结果不能有重复 数组中的每个数字可以用多次举例分析：对于[2,3,6] target=7返回[2,2,3] Java代码实现1234567891011121314151617181920212223//Backtracking Solution回溯解法public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); //需要排序,这样返回的结果一定是升序 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;(); getResult(res, tmp, candidates, 0, target); return res; &#125; private void getResult(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp, int [] candidates, int start,int target)&#123; if(target&gt;0)&#123; for(int i = start;i&lt;candidates.length &amp;&amp; target&gt;=candidates[i]; i++)&#123; tmp.add(candidates[i]); //对于任意一个数，只有两种可能，存在和不存在。 getResult(res, tmp, candidates, i, target - candidates[i]); tmp.remove(tmp.size()-1); &#125; &#125; else if(target == 0)&#123; res.add(new ArrayList(tmp)); //存储时需要新建成ArrayList类型。？？？？？？ &#125; &#125;&#125;","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-38-Count and Say","date":"2016-03-17T15:21:26.000Z","path":"2016/03/17/LeetCode-38/","text":"题目 对于给定的数字，用平时读取数字的习惯（几个1几个2…），把数读出来，读取到的数字，组成的新数作为下一层循环的输入。输入n,输出列表中第n个字符串 描述 举例分析：1,11,21,1211,111221，…详细介绍：1 平时读1个1，所以读作11,11作为下一个输入，进行循环11 平时读2个1，多以下一个是2121 平时读1个2,1个1，所以下一个是12111211 平时读1个1,1个2,2个1，所以下一个是111221 Java代码实现12345678910111213141516171819202122public class Solution &#123; public String countAndSay(int n) &#123; if(n ==1) return \"1\"; String tmp = countAndSay(n-1); char [] tmp_char = tmp.toCharArray(); //显然是用递归实现 String res = \"\"; int num =1; for(int i =0;i&lt;tmp_char.length-1;i++)&#123; if (tmp_char[i] == tmp_char[i+1])&#123; num++; &#125; else&#123; res += String.valueOf(num); res += tmp_char[i]; num = 1; &#125; &#125; res += String.valueOf(num); //最后的一个数字的统计 res += tmp_char[tmp_char.length-1]; return res; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"LeetCode-36-Valid Sudoku","date":"2016-03-17T15:11:20.000Z","path":"2016/03/17/LeetCode-36/","text":"题目 判断数独的合法行 描述 题目中，对于没有数字填充的用’.’进行填充数独合法性要求： 满足每一行、没一列、每一个九宫格内的数字都是1-9，而且不重复 java代码实现12345678910111213141516171819202122232425public class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; boolean [][]sum1 = new boolean [9][9]; //判断行是否符合要去偶 boolean [][]sum2 = new boolean [9][9]; //列 boolean [][]sum3 = new boolean [9][9]; //九宫格 for(int i =0;i&lt;9;i++)&#123; Arrays.fill(sum1[i],false); Arrays.fill(sum2[i],false); Arrays.fill(sum3[i],false); &#125; for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0;j &lt; board[i].length;j++)&#123; if(board[i][j] != '.')&#123; int num = Integer.valueOf(String.valueOf(board[i][j]))-1; //char不能直接转int int k = i/3*3 + j/3; //该位置属于第几个九宫格 if(sum1[i][num] || sum2[j][num] || sum3[k][num])&#123; return false; &#125; sum1[i][num] = sum2[j][num] = sum3[k][num] = true; &#125; &#125; &#125; return true; &#125;&#125;","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-35-Search Insert Position","date":"2016-03-17T15:07:01.000Z","path":"2016/03/17/LeetCode-35/","text":"题目 现有一个已经排好序的数组，对于给定target，查找target在数组中插入的位置，保证数组依然是个升序排列 描述 举例说明：[1,3,5,6] target = 5 -&gt;2[1,3,5,6] target = 2 -&gt;1[1,3,5,6] target = 7 -&gt;4[1,3,5,6] target = 0 -&gt;0 Java代码实现12345678910public class Solution &#123; public int searchInsert(int[] nums, int target) &#123; if(target &lt; nums[0]) return 0; int i = 0; while(i &lt; nums.length &amp;&amp; nums[i] &lt; target) i++; return i; &#125;&#125;","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-34-Search for a Range","date":"2016-03-17T06:57:25.000Z","path":"2016/03/17/LeetCode-34/","text":"题目 给定一个排好序的数组，寻找到target在数组中的起始位置和结束位置 描述 要求：时间复杂度是O(logn)如果target不在数组中，返回[-1,-1]举例说明：对于[5,7,7,8,8,10],target = 8输出[3,4]通过时间复杂度可以看出，很显然需要二分查找。 Java代码实现123456789101112131415161718192021222324public class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int [] res = &#123;-1,-1&#125;; int i = 0, j = nums.length - 1; while(i&lt;j)&#123; //先找左边的数 int mid = (i + j)/2; if(nums[mid] &lt; target) i = mid + 1; else j = mid; //nums[mid] = target时，因为需要首次出现的位置，所以肯定会出现在前半段。 &#125; if(nums[i] == target) res[0] = i; else return res; j = nums.length - 1; //从首次出现的位置至数组最末端，查找最后一次出现的位置 while(i&lt;j)&#123; int mid = (i + j)/2 +1; //很重要，举例说明，[2,3]target = 2,如果不加1，会进入死循环 if(nums[mid] &gt; target) j = mid - 1; else i = mid; //在target==nums[mid]时，需要在后半端查找 &#125; res[1] = j; return res; &#125;&#125;","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-31-Next Permutation","date":"2016-03-17T06:42:19.000Z","path":"2016/03/17/LeetCode-31/","text":"题目 下一个排列组合 描述 要求： 将排列中的数字重新排列成字典序中的下一个更大的排列。 如果这样的重新排列是不可能的，它必须重新排列为可能的最低顺序（即升序排序）。 重排必须在原地，不分配额外的内存。 举例分析：对于输入 6 5 4 8 7 5 1 从后面开始看，8 7 5 1都是递减的，寻找到第一个非递减的元素4 找到递增的位置4，从后面的递减序列中找到所有比4大的数中的最小者，例子中为5 将5与4互换，序列变为6 5 5 8 7 4 1 将关键点后的序列进行升序排列，即得到最终的结果，结果为 6 5 5 1 4 7 8 Java代码实现123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public void nextPermutation(int[] nums) &#123; int len = nums.length; int index = -1; //存储关键点位置 for(int i = len-1;i &gt;= 1;i--)&#123; if(nums[i] &gt; nums[i-1])&#123; index = i-1; break; &#125; &#125; if(index == -1)&#123; reverse(nums); //关键点不存在，所以序列已经是倒序的，返回正序的序列 &#125;else &#123; int _first = index+1; //寻找关键点后面比关键点大的，最小的数 for(int i = len-1; i &gt; index; i--)&#123; if(nums[i] &lt;= nums[_first] &amp;&amp; nums[i] &gt; nums[index])&#123; _first = i; &#125; &#125; swap(nums, index, _first); //交换关键点和后面的比自己大的最小的数 Arrays.sort(nums, index+1,len); //对关键点后的数进行排序，即为最后的结果 &#125; &#125; public void swap(int[] nums, int x, int y) &#123; int temp = nums[x]; nums[x] = nums[y]; nums[y] = temp; &#125; public void reverse(int [] nums)&#123; int len = nums.length; for(int i = 0; i &lt; len/2; i++)&#123; swap(nums, i, len-1-i); &#125; &#125;&#125;","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-29-Divide Two Integers","date":"2016-03-17T06:22:28.000Z","path":"2016/03/17/LeetCode-29/","text":"题目 实现两个整数相除的商，但是不能使用×/%这三种运算，如果结果越界，返回MAX_INT 描述 思路就是运用减法，根据被除数里面包含的除数的个数得出结果边界条件： 除数为0时，返回MAX_INT 被除数 = MIN_INT，除数 = -1,因为abs(INT_MIN) = INT_MAX + 1 举例分析：对于15/3 首先3&lt;6（6包含2个3） 6&lt;12（12包含4个3） 12&lt;&lt;1,变为24,15&lt;24（24包含8个3） 所以 15 = 3*4 + 3 对于3，重复进行那个上述操作 Java代码实现1234567891011121314151617181920public class Solution &#123; public int divide(int dividend, int divisor) &#123; //dividend：被除数，divisor：除数 if(divisor == 0) return Integer.MAX_VALUE; if(dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) return Integer.MAX_VALUE; int sign = (dividend ^ divisor) &lt;0 ? -1: 1; //符号位 long divd = Math.abs((long)dividend); //利用long进行存储 long divs = Math.abs((long) divisor ); int res = 0; while(divd &gt;= divs)&#123; long temp = divs, multiple = 1; //multiple记录所含除数的个数 while(divd &gt;= (temp&lt;&lt;1))&#123; temp &lt;&lt;= 1; multiple &lt;&lt;= 1; &#125; divd -= temp; res += multiple; &#125; return sign &gt;0 ? res:0-res; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"LeetCode-28-Implement strStr()","date":"2016-03-14T12:53:36.000Z","path":"2016/03/14/LeetCode-28/","text":"题目 对于给定的字符串haystack和needle，如果needle是haystack的子串，返回needle在haystack中出现的首个下标，否则返回-1 描述 通过字符串截取，截取haystack中[i:i+needle.length()]的子串，与needle进行比较，遍历得到最终的结果 Java代码实现123456789101112131415161718public class Solution &#123; public int strStr(String haystack, String needle) &#123; if(needle.equals(\"\"))&#123; return 0; &#125; int res = -1; int len = needle.length(); String tmp; for(int i = 0;i&lt;=haystack.length()-len;i++)&#123; tmp = haystack.substring(i,i+len); if(tmp.equals(needle))&#123; res = i; break; &#125; &#125; return res; &#125;&#125; Python代码实现123456789101112131415class Solution(object): def strStr(self, haystack, needle): \"\"\" :type haystack: str :type needle: str :rtype: int \"\"\" if not needle: return 0 res = -1 ne_len = len(needle) for i in range(len(haystack)-ne_len+1): if haystack[i:i+ne_len] == needle: return i return res","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"SQL高级教程（四）","date":"2016-03-11T08:16:56.000Z","path":"2016/03/11/sql-4/","text":"13、SQL常用函数13-1、AVG函数 AVG函数返回数值列的平均值。NULL值不包括在计算中 1SELECT AVG(column_name) FROM table_name 13-2、COUNT函数 COUNT函数返回匹配指定条件的行数。 123456返回column_name，该列的数目SELECT COUNT(column_name) FROM table_name返回数据表的记录数（即数据表有多少行）SELECT COUNT(*) FROM table_name返回某列不同值的数目SELECT COUNT(DISTINCT column_name) FROM table_name 13-3、FIRST、LAST函数 返回指定字段的第一个或最后一个值 1234返回column_name的第一个值SELECT FIRST(column_name) FROM table_name返回column_name的最后一个值SELECT LAST(column_name) FROM table_name 13-4、MAX、MIN、SUM函数 返回某一列的最大值或最小值或综合 123456返回column_name的最大值SELECT MAX(column_name) FROM table_name返回column_name的最小值SELECT MIN(column_name) FROM table_name返回column_name的总和SELECT SUM(column_name) FROM table_name 13-5、GROUP BY函数 用于结合合计函数，根据一个或多个列对结果集进行分组 123GROUP BY Customer，依据Customer进行分组，相同的列为一组，分别计算出每组的和。SELECT Customer,SUM(OrderPrice) FROM table_nameGROUP BY Customer 13-6、HAVING函数 WHERE子句无法与合计函数一起使用，所以引入HAVING函数 1234举例如下：SELECT Customer,SUM(OrderPrice) FROM OrdersGROUP BY CustomerHAVING SUM(OrderPrice)&lt;2000 13-７、UCASE、LCASE函数 对应列进行大写或者小写的变换 12举例如下：SELECT UCASE(column_name) FROM table_name 13-8、MID函数 用于从文本中提取字符 123456用法：SELECT MID(column_name,start[,length]) FROM table_name注：start是必须的，起始点是1length是截取字符串长度，可选，不写的化，返回剩余文本举例如下：SELECT MID(City,1,3) as SmallCity FROM Persons 13-９、LEN函数 LEN返回文本字段的长度 12举例如下：SELECT LEN(column_name) FROM table_name 13-10、ROUND函数 ROUND返回把数值舍入指定位数后的数字 12345用法：SELECT ROUND(column_name,decimals) FROM table_name其中decimals为小数的位数举例说明：SELECT ProductName, ROUND(UnitPrice,0) as UnitPrice FROM Products 13-11、FORMAT函数 FORMAT 函数用于对字段的显示进行格式化 123456用法：SELECT FORMAT(column_name,format) FROM table_name其中，format是必须的，规定数据的格式举例如下：SELECT ProductName, UnitPrice, FORMAT(Now(),'YYYY-MM-DD') as PerDateFROM Products","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"SQL高级教程（三）","date":"2016-03-11T07:08:30.000Z","path":"2016/03/11/sql-3/","text":"8、创建索引 CREATE INDEX创建表的索引在不查询整张表的情况下，索引使数据库应用程序可以更快地查找数据。 123456789101112创建简单的索引，允许重复CREATE INDEX index_nameON table_name (column_name)创建多个索引CREATE INDEX PersonIndexON Person (LastName, FirstName)创建唯一的索引，唯一的索引意味着两个行不能拥有相同的索引值。CREATE UNIQUE INDEX index_nameON table_name (column_name)降序索引某一列的值，用DESCCREATE INDEX PersonIndexON Person (LastName DESC) 9、ALTER ALTER TABLE 语句用于在已有的表中添加、修改或删除列。具体如下所示：123456789在表中添加列ALTER TABLE table_nameADD column_name datatype在表中删除列ALTER TABLE table_name DROP COLUMN column_name改变列的数据类型ALTER TABLE table_nameALTER COLUMN column_name datatype 10、INCREMENT AUTO INCREMENt在每次插入记录时，自动创建主键字段的值默认是从0开始，每条记录递增1，如果向要从指定值开始递增，代码如下：ALTER TABLE TABLE_name AUTO_INCREMENT=100 Mysql语法如下：1234567CREATE TABLE Persons(P_Id int NOT NULL AUTO_INCREMENT,LastName varchar(255) NOT NULL,FirstName varchar(255),PRIMARY KEY (P_Id)) 注：插入数据时，不必对P_Id进行赋值，系统会自动进行数据的分配。例如：12INSERT INTO Persons (FirstName,LastName)VALUES ('Bill','Gates') 11、NULLS IS NULL 和 IS NOT NULL 12SELECT LastName,FirstName,Address FROM PersonsWHERE Address IS NULL 12、isnull() MySQL中，IFNULL() 函数使用 123SELECT ProductName,UnitPrice*(UnitsInStock+IFNULL(UnitsOnOrder,0))FROM Products","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"SQL高级教程（二）","date":"2016-03-11T02:09:33.000Z","path":"2016/03/11/sql-2/","text":"7、SQL约束7-1、NOT NULL 不接受NULL值 12345678CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)) 7-2、UNIQUE UNIQUE约束唯一标示数据库中的记录，每个表可以有多个约束 12345678910111213141516171819Mysql:CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),UNIQUE (Id_P))SQL server/Oracle/MS Access:CREATE TABLE Persons(Id_P int NOT NULL UNIQUE,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)) 如果需要命名 UNIQUE 约束，以及为多个列定义 UNIQUE 约束，请使用下面的 SQL 语法： 123456789CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)) 对于已经创建的数据库，想要添加唯一性属性，代码如下： 12ALTER TABLE PersonsADD UNIQUE (Id_P) 撤销UNIQUE约束： 123456Mysql:ALTER TABLE PersonsDROP UNIQUE uc_PersonID其他：ALTER TABLE PersonsDROP CONSTRANT uc_PersonID 7-3、Primary Key PRIMARY KEY 约束唯一标识数据库表中的每条记录。主键必须包含唯一的值。主键列不能包含 NULL 值。每个表都应该有一个主键，并且每个表只能有一个主键。 具体语法同上！ 7-4、FOREIGN KEY 一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEYFOREIGN KEY 约束用于预防破坏表之间连接的动作。FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。 123456789Mysql:CREATE TABLE Orders(Id_O int NOT NULL,OrderNo int NOT NULL,Id_P int,PRIMARY KEY (Id_O),FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)) 如果需要命名 FOREIGN KEY 约束，以及为多个列定义 FOREIGN KEY 约束，请使用下面的 SQL 语法： 123456789CREATE TABLE Orders(Id_O int NOT NULL,OrderNo int NOT NULL,Id_P int,PRIMARY KEY (Id_O),CONSTRAINT fk_PerOrders FOREIGN KEY (Id_P)REFERENCES Persons(Id_P)) 对于已经创建的数据库添加FOREIGN KEY 123456789方式一：ALTER TABLE OrdersADD FOREIGN KEY (Id_P)REFERENCES Persons(Id_P)方式二：ALTER TABLE OrdersADD CONSTRAINT fk_PerOrdersFOREIGN KEY (Id_P)REFERENCES Persons(Id_P) 对于已经创建的数据库删除FOREIGN KEY 123456Mysql：ALTER TABLE OrdersDROP FOREIGN KEY fk_PerOrders其他:ALTER TABLE OrdersDROP CONSTRAINT fk_PerOrders 7-5、CHECK CHECK 约束用于限制列中的值的范围。 123456789CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CHECK (Id_P&gt;0)) 如果需要命名 CHECK 约束，以及为多个列定义 CHECK 约束，请使用下面的 SQL 语法： 123456789CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT chk_Person CHECK (Id_P&gt;0 AND City='Sandnes')) 对于已构建的数据库，进行CHECK的添加和删除操作，形式与前面讲的基本一样 7-6、DEFAULT DEFAULT 约束用于向列中插入默认值。 12345678CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255) DEFAULT 'Sandnes') 对于已经简历的数据库，操作如下;添加DEFAULT：123456Mysql：ALTER TABLE PersonsALTER City SET DEFAULT 'SANDNES'其他：ALTER TABLE PersonALTER COLUMN City SET DEFAULT 'SANDNEWS' 删除DEFAULT123456Mysql：ALTER TABLE PersonsALTER City DROP DEFAULT其他：ALTER TABLE PersonALTER COLUMN City DROP DEFAULT","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"LeetCode27-Remove Element","date":"2016-03-10T13:02:39.000Z","path":"2016/03/10/LeetCode-27/","text":"题目 对于指定的数字val，删除数组nums中包含val的元素 分析 给定数字val，以及数组nums，删除数组中出现的val元素，删除val后的数字元素，排在nums数组的前面，后面的数字无要求。 java代码实现12345678910111213public class Solution &#123; public int removeElement(int[] nums, int val) &#123; if(nums.length == 0) return 0; int j = 0; for(int i=0; i&lt;nums.length; i++)&#123; if(nums[i] != val)&#123; nums[j] = nums[i]; j++; &#125; &#125; return j; &#125;&#125; python代码实现12345678910111213141516class Solution(object): def removeElement(self, nums, val): \"\"\" :type nums: List[int] :type val: int :rtype: int \"\"\" j = 0 if(len(nums) == 0): return 0 else: for i in range(len(nums)): if(nums[i] != val): nums[j] = nums[i] j += 1 return j","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode26-Remove Duplicates from Sorted Array","date":"2016-03-10T12:40:28.000Z","path":"2016/03/10/LeetCode-26/","text":"题目 删除排好顺序的数组里面的重复元素 分析 对于数组nums = [1,1,2]，返回 length = 2，并且数组的前两个元素为1,2。也就是说，数组的前length个元素位本数组完全不同的数字。要求：不能开辟新的内存空间，空间复杂度O(1) java代码实现12345678910111213141516public class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length == 0)&#123; return 0; &#125; int i = 1; int j = 0; for(; i&lt;nums.length; i++)&#123; if(nums[i] != nums[j])&#123; j++; nums[j] = nums[i]; &#125; &#125; return j+1; &#125;&#125; python代码实现123456789101112131415class Solution(object): def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) == 0: return 0 i = 0 j = 0 for i in range(len(nums)): if nums[i] != nums[j]: j += 1 nums[j] = nums[i] return j+1","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"SQL高级教程（一）","date":"2016-03-10T09:29:09.000Z","path":"2016/03/10/sql-1/","text":"1、INSERT、UPDATE12&gt; INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)&gt; UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值 2、通配符通配符主要配合人LIKE使用 % 代替一个或多个字符 _ 仅代替一个字符 [] 代替字符列中的任意字符 [^]代替任意非字符列中的字符 12&gt; select \\* from 表名 where 列名 like '[ab]%' 找出以a或b开头的数据&gt; select \\* from 表名 where 列名 like 'ab%' 找出以ab开头的数据 3、IN、BETWEENIN 操作符允许我们在 WHERE 子句中规定多个值。 12&gt; SELECT column_name(s) FROM table_name WHERE column_name IN (value1,value2,...) 选出列值为value1....的列&gt; SELECT column_name(s) FROM table_name WHERE column_name BETWEEN value1 AND value2 3、INNER/LEFT/RIGHT/FULL JOIN1234&gt; SELECT column_name(s) FROM table_name1 INNER JOIN table_name2 ON table_name1.column_name=table_name2.column_name（只显示匹配上的值）&gt; SELECT column_name(s) FROM table_name1 LEFT JOIN table_name2 ON table_name1.column_name=table_name2.column_name（从左表 (table_name1) 那里返回所有的行，即使在右表 (table_name2) 中没有匹配的行，没有匹配输出空）&gt; SELECT column_name(s) FROM table_name1 RIGHT JOIN table_name2 ON table_name1.column_name=table_name2.column_name（从右表 (table_name2) 那里返回所有的行，即使在左表 (table_name1) 中没有匹配的行，没有匹配输出空）&gt; SELECT column_name(s) FROM table_name1 FULL JOIN table_name2 ON table_name1.column_name=table_name2.column_name（只要其中某个表存在匹配，FULL JOIN 关键字就会返回行，没有匹配上的表设为空） 4、UNION和UNION ALLUNION 操作符用于合并两个或多个 SELECT 语句的结果集,将选取的两列结果合并成一列输出。请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 注意：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL 1&gt; SELECT E_Name FROM Employees_China UNION SELECT E_Name FROM Employees_USA 5、SELECT INTOSELECT INTO 语句从一个表中选取数据，然后把数据插入另一个表中。SELECT INTO 语句常用于创建表的备份复件或者用于对记录进行存档。 下面的例子会创建一个新表，其中包含了从 Persons 和 Orders 两个表中取得的信息：1234SELECT Persons.LastName,Orders.OrderNoINTO Persons_Order_BackupFROM Persons INNER JOIN OrdersON Persons.Id_P=Orders.Id_P 6、CREATE TABLE数据类型： 数据类型描述int(size)integer(size)仅容纳整数，括号内是规定数字的最大位数decimal(size,d)numeric(size,d)容纳带小数的数字(作为字符串存储的小树)。size是数字的最大位数,d是小数点后最大位数char(size)容纳固定长度的字符串(可容纳字母、数字、特殊字符)varchar(size)容纳可变长度的字符串(可容纳字母、数字、特殊字符)，size为最大长度date(yyyymmdd)容纳日期 12345678CREATE TABLE Persons(Id_P int,LastName varchar(255),FirstName varchar(255),Address varchar(255),City varchar(255))","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"Hash算法实现-MD5","date":"2016-03-09T12:19:44.000Z","path":"2016/03/09/hash/","text":"1、MD5简介 MD5是RSA数据安全公司开发的一种单向散列算法，具体特点是： 无论多长多随意的信息，最后都转换成一个固定长度（128bit）的散列值； 对于大量不同的信息，最后出来的散列值呈平均分布； 对于特定的一个信息，最后出来的散列值都是相同的。 已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 2、MD5算法应用2-1、一致性验证 MD5典型的应用是对一段meaasge产生信息摘要（message digest），以防止被篡改，例如，平时我们在网上下载软件，而这些软件已经注入了病毒，如果不进行文件域原始发布商的一致性校验的化，很可能造成一定损失。所以平时下载的软件一般包含一个md5文件，用来验证文件的一致性 2-2、安全访问认证 Unix系统中对用户的密码是一MD5（或其他类似算法）经过hash运算后存储在文件系统中的，在用户登陆时，将密码进行MD5 Hash运算，然后再去和文件系统中的MD5值进行比对。通过这样的步骤，系统会在不知道用户明文密码的情况下实现密码的验证工作。 3、MD5算法实现3-1、第一步-填充 首先对信息进行填充，使其位数对512求余的结果是448，因此填充后的信息的位长（Bites length）是N*512+448，填充的规则是在信息的后面，添加1个1和无数个0，知道满足要求为止。 3-2、第二步-补足长度 将原数据的长度转换位64bit的数值，如果长度超过64bit，只保留最后的64bit，将该64bit数值添加到第一步的信息后面，这样就形成了一个(N+1)*512 bit的信息。 3-3、第三步-初始化变量 用四个变量，分别位A、B、C、D，均为32bit长，初始化为： A=(01234567)16 B=(89ABCDEF)16 C=(FEDCBA98)16 D=(76543210)16 3-4、第四步-操作定义 1、首先定义四个辅助函数(其中 &amp;-与，|-或，～-非，^-亦或，X、Y、Z均为32bit) F(X,Y,Z) = (X&amp;Y)|((~X)&amp;Z) G(X,Y,Z) = (X&amp;Z)|(Y&amp;(~Z)) H(X,Y,Z) = X\\^Y\\^Z I(X,Y,Z) = Y^(X|(~Z)) 2、定义四个操作(&lt;&lt;&lt; s表示循环左移s位，Mj) FF(a,b,c,d,Mj,s,ti) 表示 b+((a+F(b,c,d)+Mj+T(i))&lt;&lt;&lt;s) GG(a,b,c,d,Mj,s,ti) 表示 b+((a+G(b,c,d)+Mj+T(i))&lt;&lt;&lt;s) HH(a,b,c,d,Mj,s,ti) 表示 b+((a+H(b,c,d)+Mj+T(i))&lt;&lt;&lt;s) II(a,b,c,d,Mj,s,ti) 表示 b+((a+I(b,c,d)+Mj+T(i))&lt;&lt;&lt;s) 其中T(i)(i取值1-64)等于abs(sin(i))的4294967296倍(4294967296等于2的32次方)的整数部分,i为弧度(rad)。即T(i) = 232*abs(sin(i)) (1=&lt;i&lt;=64) 3-5、第五步-分組处理 总共进行4论(N+1)，对于前面得到的512(N+1) bit信息，按没512bit进行分组，分成Y1，Y2….YN+1，对于每个Yi分解长M0……M15，每32bit一组。然后进行4*(N+1)论处理。其中:a=A=(01234567)16、b=B=(89ABCDEF)16、c=C=(FEDCBA98)16、d=D=(76543210)16第一轮： a=FF(a,b,c,d,M0,7,0xd76aa478) b=FF(d,a,b,c,M1,12,0xe8c7b756) c=FF(c,d,a,b,M2,17,0x242070db) d=FF(b,c,d,a,M3,22,0xc1bdceee) a=FF(a,b,c,d,M4,7,0xf57c0faf) b=FF(d,a,b,c,M5,12,0x4787c62a) c=FF(c,d,a,b,M6,17,0xa8304613) d=FF(b,c,d,a,M7,22,0xfd469501) a=FF(a,b,c,d,M8,7,0x698098d8) b=FF(d,a,b,c,M9,12,0x8b44f7af) c=FF(c,d,a,b,M10,17,0xffff5bb1) d=FF(b,c,d,a,M11,22,0x895cd7be) a=FF(a,b,c,d,M12,7,0x6b901122) b=FF(d,a,b,c,M13,12,0xfd987193) c=FF(c,d,a,b,M14,17,0xa679438e) d=FF(b,c,d,a,M15,22,0x49b40821) 第二轮： a=GG(a,b,c,d,M1,5,0xf61e2562) b=GG(d,a,b,c,M6,9,0xc040b340) c=GG(c,d,a,b,M11,14,0x265e5a51) d=GG(b,c,d,a,M0,20,0xe9b6c7aa) a=GG(a,b,c,d,M5,5,0xd62f105d) b=GG(d,a,b,c,M10,9,0x02441453) c=GG(c,d,a,b,M15,14,0xd8a1e681) d=GG(b,c,d,a,M4,20,0xe7d3fbc8) a=GG(a,b,c,d,M9,5,0x21e1cde6) b=GG(d,a,b,c,M14,9,0xc33707d6) c=GG(c,d,a,b,M3,14,0xf4d50d87) d=GG(b,c,d,a,M8,20,0x455a14ed) a=GG(a,b,c,d,M13,5,0xa9e3e905) b=GG(d,a,b,c,M2,9,0xfcefa3f8) c=GG(c,d,a,b,M7,14,0x676f02d9) d=GG(b,c,d,a,M12,20,0x8d2a4c8a) 第三轮： a=HH(a,b,c,d,M5,4,0xfffa3942) b=HH(d,a,b,c,M8,11,0x8771f681) c=HH(c,d,a,b,M11,16,0x6d9d6122) d=HH(b,c,d,a,M14,23,0xfde5380c) a=HH(a,b,c,d,M1,4,0xa4beea44) b=HH(d,a,b,c,M4,11,0x4bdecfa9) c=HH(c,d,a,b,M7,16,0xf6bb4b60) d=HH(b,c,d,a,M10,23,0xbebfbc70) a=HH(a,b,c,d,M13,4,0x289b7ec6) b=HH(d,a,b,c,M0,11,0xeaa127fa) c=HH(c,d,a,b,M3,16,0xd4ef3085) d=HH(b,c,d,a,M6,23,0x04881d05) a=HH(a,b,c,d,M9,4,0xd9d4d039) b=HH(d,a,b,c,M12,11,0xe6db99e5) c=HH(c,d,a,b,M15,16,0x1fa27cf8) d=HH(b,c,d,a,M2,23,0xc4ac5665) 第四轮： a=II(a,b,c,d,M0,6,0xf4292244) b=II(d,a,b,c,M7,10,0x432aff97) c=II(c,d,a,b,M14,15,0xab9423a7) d=II(b,c,d,a,M5,21,0xfc93a039) a=II(a,b,c,d,M12,6,0x655b59c3) b=II(d,a,b,c,M3,10,0x8f0ccc92) c=II(c,d,a,b,M10,15,0xffeff47d) d=II(b,c,d,a,M1,21,0x85845dd1) a=II(a,b,c,d,M8,6,0x6fa87e4f) b=II(d,a,b,c,M15,10,0xfe2ce6e0) c=II(c,d,a,b,M6,15,0xa3014314) d=II(b,c,d,a,M13,21,0x4e0811a1) a=II(a,b,c,d,M4,6,0xf7537e82) b=II(d,a,b,c,M11,10,0xbd3af235) c=II(c,d,a,b,M2,15,0x2ad7d2bb) d=II(b,c,d,a,M9,21,0xeb86d391) 3-6、第六步-输出 最后： a = a+A b = b+B c = c+C d = d+D abcd即为最终的结果，共计128bit","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"python编程规范","date":"2016-02-29T16:00:00.000Z","path":"2016/03/01/python-code-style/","text":"1、推荐使用pep8编译python代码1pip install pep8 运行python代码时，执行： 1pep8 xxx.py 2、True/False使用尽可能使用隐式的False,按简单的直觉来讲，就是所有的“空”值都是False，因此0、None、[]、{}、””都被认为是False 注： 永远不要使用==或者!=来比较单件，比如None 利用 is或者 is not，其中if x:,实际的含义就是if x is not None: 对于非None的比较，使用if not x: 处理整数时, 使用隐式false可能会得不偿失(即不小心将None当做0来处理). 你可以将一个已知是整型(且不是len()的返回结果)的值与0比较. 3、Lambda函数适用于单行函数 123456&gt;&gt;&gt;func = lambda x: x*2 # 定义lambda函数，并将其赋给func，通过func调用&gt;&gt;&gt;func(3)6&gt;&gt;&gt;(lambda x,y: x + y)(3,4) # lambda函数的定义和调用也可以整合在一起（可读性差）7 4、函数和方法装饰器如果好处很显然, 就明智而谨慎的使用装饰器 下面两段代码是等效的 1234class C(objext): @my_decorator def method(self): # method body...... 1234class C(object): def method(self): # method body...... method = my_decorator(method) 5、空行顶级定义之间空两行，方法定义之间空一行 顶级定义（函数或这类定义）之间空两行，方法定义以及类与第一个方法之间，都该空一行 6、空格按照标准的排版规范来使用标点两边的空格 括号内不要有空格 1spam(ham[1], &#123;egg: 2&#125;,[]) 不要在逗号、分号、冒号前面加空格，但应该在他们后面加（除了在行尾） 123if x ==4: print x, y x, y = y, x 在二元操作符两边都要加上一个空格。比如：赋值(=)，比较(==, &lt;, &gt;, !=, &gt;=, &lt;=, in, not in, is, is not)，布尔（and, or, not） 1if x ==4: ‘=’用于只是关键字参数或默认参数时，不要在其两端加空格 1def complex(real, image=0.1): return magic(r=real, i=image) 7、类如果一个类不继承自其他类，就显式的从object类继承 1class SimpleClass(object): 8、字符串即使参数都是字符串，使用%操作符或者格式化方法格式化字符串，不过也不能一概二论，需要在+和%之间好好判断 12345x = a + bx = '%s, %s!' % (a, b)x = '&#123;&#125;, &#123;&#125;!'.format(a, b)x = 'name: %s; score: %d' % (name, n)x = 'name: &#123;&#125;; score: &#123;&#125;'.format(name, score) 9、文件和sockets在文件和sockets结束时，显示的关闭它推荐使用with语句管理文件 123with open('hello.txt') as hello_file: for line in hello_file: print line 10、导入格式每个导入应该独占一行 12import osimport sys 导入顺序： 标准库导入 第三方库导入 应用程序指定导入 11、命名 module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_VAR_NAME, instance_var_name, function_parameter_name, local_var_name","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"LeetCode25-Reverse Nodes in k-Group","date":"2016-02-23T16:00:00.000Z","path":"2016/02/24/LeetCode-25/","text":"题目 交换链表中相邻的k个数举例：输入：a-&gt;b-&gt;c-&gt;d,k=3输出：c-&gt;b-&gt;a-&gt;d 分析对于k=3的情况 -1(pre) -&gt; 1(cur) -&gt; 2(nex) -&gt; 3 -&gt; 4 -&gt; 5 -1(pre) -&gt; 2 -&gt; 1(cur) -&gt; 3(nex) -&gt; 4 -&gt; 5 -1(pre) -&gt; 3 -&gt; 2 -&gt; 1(cur) -&gt; 4(nex) -&gt; 5 始终是：123456for i in range(k-1) tmp = pre.next pre.next = cur.next cur.next = nex.next nex.next = tmp nex = cur.next python代码实现1234567891011121314151617181920212223242526272829class Solution(object): def reverseKGroup(self, head, k): \"\"\" :type head: ListNode :type k: int :rtype: ListNode \"\"\" if not head or k == 1: return head pre = ListNode(0) pre.next = head res = cur = nex = tmp = pre count = 0 while(cur.next): count += 1 if count == k: cur = pre.next nex = cur.next for i in range(k-1): tmp = pre.next pre.next = cur.next cur.next = nex.next nex.next = tmp nex = cur.next count = 0 pre = cur cur = cur.next return res.next","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode24-Swap Nodes in Pairs","date":"2016-02-21T16:00:00.000Z","path":"2016/02/22/LeetCode-24/","text":"题目 交换链表中每相邻的两个结点 分析 对于 a-b-c-d，交换后为b-a-d-c python代码实现12345678910111213141516171819class Solution(object): def swapPairs(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" res = ListNode(0) res.next = head cur = res while cur.next and cur.next.next: a = cur.next b = cur.next.next cur.next, b.next, a.next = b, a, b.next # c = b.next # cur.next = b # b.next = a # a.next = c cur = a return res.next","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode22-Generate Parentheses","date":"2016-02-20T16:00:00.000Z","path":"2016/02/21/LeetCode-22/","text":"题目 给定数字n，输出合法的括号组合，结果由n个括号组成例如：输入为2输出结果为： “(())”,”()()” 分析 该题目实际上即为考察二叉树，即左分支用于添加”(“,右分支用于添加”)” python代码实现12345678910111213141516171819class Solution(object): def generateParenthesis(self, n): \"\"\" :type n: int :rtype: List[str] \"\"\" res = self.dfs([], \"\", n, n) return res def dfs(self, res, tmp, left, right): if(0==left and 0==right): res.append(tmp) return elif left &gt; 0: self.dfs(res, tmp + \"(\", left-1, right) if right &gt; left: self.dfs(res, tmp + \")\", left, right-1) return res C++代码实现12345678910111213141516171819202122class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; if (n == 0) return vector&lt;string&gt;(); vector&lt;string &gt; ret; dfs(ret, \"\", n, n); return ret; &#125; //利用二叉树递归思想 void dfs(vector&lt;string&gt; &amp;ret, string tmp, int left, int right) &#123; if (0 == left &amp;&amp; 0 == right) &#123; ret.push_back(tmp); return; &#125; else if (left &gt; 0) dfs(ret, tmp + '(', left - 1, right); if (left &lt; right) dfs(ret, tmp + ')', left, right - 1); &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"回溯","slug":"回溯","permalink":"http://yoursite.com/tags/回溯/"}]},{"title":"数据结构-栈","date":"2016-02-13T05:31:09.000Z","path":"2016/02/13/data-structure-stack/","text":"1、准备数据本文所使用的数据结构如代码所示 12345678910class Data&#123; String name; int age;&#125;class Stack&#123; static final int MAXLEN = 100; //栈的最大容量 Data [] data = new Data [MAXLEN]; int top; //栈顶&#125; 2、初始化栈1234567891011Stack initStack()&#123; Stack res; if((res = new Stack())==null)&#123; System.out.println(\"申请内存失败\"); return null; &#125; else&#123; res.top = 0; return res; &#125;&#125; 3、判断空栈、满栈3-1判断空栈 12345boolean isEmpty(Stack tmp)&#123; boolean res; res = (tmp.top==0); return res;&#125; 3-2判断满栈12345boolean isFull(Stack tmp)&#123; boolean res; res = (tmp.top==MAXLEN); return res;&#125; 4、清空栈、释放空间4-1清空栈 123void clearStack(Stack tmp)&#123; tmp.top=0;&#125; 4-2释放空间 123void freeStack(Stack tmp)&#123; tmp = null;&#125; 5、入栈12345678void pushStack(Stack tmp, Data data)&#123; if(tmp.top+1&gt;MAXLEN)&#123; System.out.println('栈满'); &#125; else&#123; tmp.data[++tmp.top] = data; &#125;&#125; 6、出栈12345678Data popStack(Stack tmp)&#123; if(tmp.top == 0)&#123; System.out.println('栈空'); &#125; else&#123; return tmp.data[tmp.top--]; &#125;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"数据结构-队列","date":"2016-02-11T05:52:28.000Z","path":"2016/02/11/data-structure-queue/","text":"1、准备数据本文所使用的数据结构如代码所示1234567891011class Data&#123; String name; int age;&#125;class Queue&#123; int head; //队列头指针 int tail; //队列尾指针 static final int QUEUELEN = 100; Data []data = new Data [QUEUELEN]; &#125; 2、初始化队列1234567891011Queue initQueue&#123; Queue res; if((res = new Queue()) == null)&#123; System.out.println(\"申请内存失败\"); return null; &#125; else&#123; res.head = res.tail = 0; return res; &#125;&#125; 3、判断空队列、满队列3-1判断空队列 123boolean isEmpty(Queue tmp)&#123; return (tmp.head==tmp.tail);&#125; 3-2判断满队列 123boolean isFull(Queue tmp)&#123; return (tmp.tail == QUEUELEN);&#125; 4、清空队列、释放空间4-1清空队列123void clearQueue(Queue tmp)&#123; tmp.head = tmp.tail = 0;&#125; 4-2释放空间123void freeQueue(Queue tmp)&#123; tmp = null;&#125; 5、入队列12345678910Queue pushQueue(Queue tmp, Data data)&#123; if(tmp.tail == QUEUELEN)&#123; System.out.println(\"满队列\"); return null; &#125; else&#123; tmp.data[++tmp.tail] = data; return tmp &#125;&#125; 6、出队列123456789Data popQueue(Queue tmp)&#123; if(tmp.head == tmp.tail)&#123; System.out.println(\"空队列\"); return null; &#125; else&#123; return tmp.data[tmp.head++]; &#125;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"数据结构-链表","date":"2016-02-10T01:53:15.000Z","path":"2016/02/10/data-structure-link/","text":"1、准备数据本文所使用数据结构如代码所示 12345678910class Data&#123; String name; String key; int age;&#125; //存储数据结构class LinkNode&#123; Data data = new Data(); Data nextData;&#125; 2、追加节点在链表的末尾追加指定的节点 12345678910111213141516171819202122LinkNode addEnd(LinkNode head, Data nodeData)&#123; LinkNode node,htemp; if((node = new LinkNode())==null)&#123; System.out.println(\"申请内存失败\"); return null; &#125; else&#123; node.nodeData = nodeData; //要插入的节点 node.nextNode = null; if(head == null)&#123; return node; //判断待插入的链表是否为空 &#125; else&#123; htemp = head; while(htemp.nextNode!=null)&#123; htemp = htemp.nextNode; &#125; htemp.nextNode = nodeData; return head &#125; &#125;&#125; 3、查找节点查找链表中的某个节点key值是与给定的key值相等12345678910LinkNode findNode(LinkNode head, String key)&#123; LinkNode node; //用户返回查找到的节点 while(LinkNode!=null)&#123; if(LinkNode.nodeData.key.compareTo(key)==0)&#123; //String.compareTo()函数比较字符串的内容，相等为0，&gt;0和&lt;0分别代表前者大于和小于后者，数值即为两者相差的ASCII值，==比较字符串在内存中的地址是否相等 return LinkNode; &#125; LinkNode = LinkNode.nextNode; &#125; return null;&#125; 4、插入节点4-1、在链表头部插入节点123456789101112LinkNode insertHead(LinkNode head, Data nodeData)&#123; LinkNode node; if((node = new LinkNode()) == null)&#123; System.out.println(\"申请内存失败\"); return null; &#125; else&#123; node.nodeData = nodeData; node.nextNode = head; return node; &#125;&#125; 4-2、在链表中间插入节点1234567891011121314151617LinkNode insertMiddle(LinkNode head, Data nodeData, String findKey)&#123; LinkNode node; if((node = new LinkNode()) == null)&#123; System.out.println(\"申请内存失败\"); return null; &#125; htemp = findNode(head, findKey);//查找需要插入的节点位置 if(htemp!=null)&#123; node.nodeData = nodeData; node.nextNode = htemp.nextNode; htemp.nextNode = node; return head; &#125; else&#123; System.out.println('未找到正确的插入节点'); &#125;&#125; 5、删除节点12345678910111213141516171819202122LinkNode deleteNode(LinkNode head, String deleteKey)&#123; LinkNode node,temp; node = head; temp = head; if(head.nodeData.key.compareTo(deleteKey)==0)&#123; return head.nextNode; &#125; else&#123; while(temp!=null)&#123; if(temp.nodeData.key.compareTo(deleteKey)==0)&#123; node.nextNode = temp.nextNode; temp = null; return head; &#125; else&#123; node = temp; temp = temp.nextNode; &#125; &#125; &#125; return null;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"LeetCode-21-Merge Two Sorted Lists","date":"2016-01-30T07:45:41.000Z","path":"2016/01/30/LeetCode-21/","text":"题目 合并两个排好续的链表 分析 略 C++代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode tmp = ListNode(-1); ListNode* res = &amp;tmp; while(l1 &amp;&amp; l2) &#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; res-&gt;next = l1; l1 = l1-&gt;next; &#125; else&#123; res-&gt;next = l2; l2 = l2-&gt;next; &#125; res = res-&gt;next; &#125; res-&gt;next = l1 ? l1:l2; return tmp.next; &#125;&#125;; /*class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode tmp = ListNode(-1); ListNode* res = &amp;tmp; while(l1 &amp;&amp; l2) &#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; res-&gt;next = l1; l1 = l1-&gt;next; res = res-&gt;next; &#125; else&#123; res-&gt;next = l2; l2 = l2-&gt;next; res = res-&gt;next; &#125; &#125; if(!l1)&#123; while(l2)&#123; res-&gt;next = l2; l2 = l2-&gt;next; res = res-&gt;next; &#125; &#125; else&#123; while(l1)&#123; res-&gt;next = l1; l1 = l1-&gt;next; res = res-&gt;next; &#125; &#125; return tmp.next; &#125;&#125;;*/ Python代码实现 # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def mergeTwoLists(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" res = ListNode(0) tmp = res while l1 is not None and l2 is not None: if l1.val &lt; l2.val: tmp.next = ListNode(l1.val) l1 = l1.next tmp = tmp.next else: tmp.next = ListNode(l2.val) l2 = l2.next tmp = tmp.next if l1 is None: tmp.next = l2 elif l2 is None: tmp.next = l1 return res.next","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode-20-Valid Parentheses","date":"2016-01-30T07:45:38.000Z","path":"2016/01/30/LeetCode-20/","text":"题目 输入只包含’(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ , ‘]’的字符串，判断字符串是否合法，”()” and “()[]{}”是合法的，”(]” and “([)]”是非合法的 分析 显然是使用栈进行实现 C++代码实现12345678910111213141516171819202122232425262728293031323334353637/*class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; tmp; tmp.push('0'); for(int i = 0; i &lt; s.size(); i ++) &#123; if(abs(tmp.top() - s[i]) &lt; 5 &amp;&amp; tmp.top() != s[i]) tmp.pop(); else tmp.push(s[i]); &#125; return tmp.size() == 1; &#125;&#125;;*/class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; tmp; for(int i = 0; i &lt; s.size(); i ++) &#123; if(s[i] == '[' || s[i] == '(' || s[i] == '&#123;') tmp.push(s[i]); else&#123; if(tmp.empty()) return false; else&#123; if(abs(tmp.top() - s[i]) &lt; 5) tmp.pop(); else return false; &#125; &#125; &#125; if(tmp.empty()) return true; else return false; &#125;&#125;; Python代码实现12345678910111213class Solution(object): def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\" stack = ['0'] for i in s: if i!=stack[-1] and abs(ord(i)-ord(stack[-1]))&lt;5: stack.pop() else: stack.append(i) return stack==['0']","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Stack","slug":"Stack","permalink":"http://yoursite.com/tags/Stack/"}]},{"title":"LeetCode-19-Remove Nth Node From End of List","date":"2016-01-30T07:45:34.000Z","path":"2016/01/30/LeetCode-19/","text":"题目 删除链表的倒数第n个元素 分析 首先计算出链表的长度k，删除倒数第n个元素，实际就是删除正数第k-n+1个元素 C++代码实现12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; int len = get_ListNodeLength(head); int k = len - n + 1; return removeNthFromBegin(head, k); &#125; int get_ListNodeLength(ListNode* head)&#123; int len = 0; while(head)&#123; len++; head = head-&gt;next; &#125; return len; &#125; ListNode* removeNthFromBegin(ListNode* head, int n)&#123; ListNode* pre = head; if(n == 1) return head-&gt;next; for(int i = 0; i &lt; n - 2; i++) pre = pre-&gt;next; pre-&gt;next = pre-&gt;next-&gt;next; return head; &#125;&#125;; Python代码实现1234567891011121314151617181920212223242526272829303132333435# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def removeNthFromEnd(self, head, n): \"\"\" :type head: ListNode :type n: int :rtype: ListNode \"\"\" num = self.sumOfList(head) res = self.removeNthFromStart(head, num + 1 - n) return res def sumOfList(self,head): temp = head res = 0 while temp is not None: res+=1 temp = temp.next return res def removeNthFromStart(self, head, n): tmp_h = head tmp_b = head if n==1: return head.next else: for i in range(n-1): tmp_b = tmp_h tmp_h = tmp_h.next tmp_b.next = tmp_h.next return head","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode-18-4Sum","date":"2016-01-30T07:45:31.000Z","path":"2016/01/30/LeetCode-18/","text":"题目 给定数组和target，从数组中找出4个数组成的所有list，使得每个的和都是target，返回的数组中不能有重复的元素。 分析 略（本文写出nSum的通用方法） C++代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res = nSum(nums, 0, 4, target); return res; &#125; //该函数适用于排好序的数组 vector&lt;vector&lt;int&gt;&gt; nSum(vector&lt;int&gt;&amp; nums, int begin, int count, int target)&#123; vector&lt;vector&lt;int&gt;&gt; res; if(count == 2)&#123; int i = begin; int j = nums.size() - 1; while(i &lt; j)&#123; int x = nums[i], y = nums[j]; if(x + y == target)&#123; vector&lt;int&gt; tmp; tmp.push_back(nums[i]); tmp.push_back(nums[j]); res.push_back(tmp); //去重 while(i &lt; nums.size() &amp;&amp; nums[i] == x) i++; while(j &gt;= begin &amp;&amp; nums[j] == y) j--; &#125; else if(x + y &lt; target) i++; else j--; &#125; &#125; else &#123; for(int i = begin; i &lt; nums.size(); i ++)&#123; // 去重 if(i &gt; begin &amp;&amp; nums[i] == nums[i-1]) continue; vector&lt;vector&lt;int&gt;&gt; tmp = nSum(nums, i + 1, count - 1, target - nums[i]); if(!tmp.empty())&#123; for(int j = 0; j &lt; tmp.size(); j++)&#123; tmp[j].push_back(nums[i]); res.push_back(tmp[j]); &#125; &#125; &#125; &#125; return res; &#125;&#125;;","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-17-Letter Combinations of a Phone Number","date":"2016-01-30T07:45:28.000Z","path":"2016/01/30/LeetCode-17/","text":"题目 电话号码解析 分析 如图所示为手机键盘，当点击任意多个键后，返回所有可能的排列组合。举例分析：输入“23”，输出[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”] C++代码实现1234567891011121314151617181920212223class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; string number_map [] = &#123;\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"&#125;; vector&lt;string&gt; res; if(digits.length() == 0) return res; res.push_back(\"\"); for(int i = 0; i &lt; digits.length(); i++)&#123; vector&lt;string&gt; tmp; string str = number_map[digits[i] - '0']; for(int j = 0; j &lt; str.size(); j++) &#123; for(int k = 0; k &lt; res.size(); k++)&#123; tmp.push_back(res[k] + str[j]); &#125; &#125; res = tmp; &#125; return res; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-16-3Sum Closest","date":"2016-01-30T07:45:22.000Z","path":"2016/01/30/LeetCode-16/","text":"题目 给定数组和target，返回数组中3个数的和，和target最相近的三个数，返回该3个数和 分析 略（双指针实现） C++代码实现123456789101112131415161718192021222324class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int res = nums[0] + nums[1] + nums[2]; int _dis = abs(target - res); for(int i = 0; i &lt; nums.size(); i++) &#123; int j = i + 1; int k = nums.size() - 1; while(j &lt; k)&#123; int sum = nums[i] + nums[j] + nums[k]; if(abs(sum - target) &lt; _dis) &#123; res = sum; _dis = abs(sum - target); &#125; else if(sum &lt; target) j++; else k--; &#125; &#125; return res; &#125;&#125;;","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-15-3Sum","date":"2016-01-30T07:45:18.000Z","path":"2016/01/30/LeetCode-15/","text":"题目 给定一个数组，寻找3个数和为0的所有组合。 分析 略（双指针实现） C++代码实现1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; num; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size(); i++) &#123; int front = i+1; int end = nums.size() - 1; while(front &lt; end) &#123; if(nums[i] + nums[front] + nums[end] == 0) &#123; num.push_back(nums[i]); num.push_back(nums[front]); num.push_back(nums[end]); res.push_back(num); //过滤掉后两个相同的元素 //Rolling the front pointer to the next different number forwards while(front &lt; end &amp;&amp; nums[front] == num[1]) front++; //Rolling the back pointer to the next different number backwards while(front &lt; end &amp;&amp; nums[end] == num[2]) end--; num.clear(); &#125; else if(nums[i] + nums[front] + nums[end] &lt; 0) front++; else end--; //过滤掉重复元素（过滤掉第一个相同的元素） while(i+1 &lt;= nums.size() &amp;&amp; nums[i+1] == nums[i]) i++; &#125; &#125; return res; &#125;&#125;;","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-14- Longest Common Prefix","date":"2016-01-30T07:45:15.000Z","path":"2016/01/30/LeetCode-14/","text":"题目 最长公共前缀字符串 分析 所有字符串最长的公共前缀 选取字符串数组中最短的字符串，作为参考 依次遍历所有字符串与参考字符串的每一位是否相等，如有不相等的，退出循环。记录相对参考字符串 C++代码实现1234567891011121314151617181920212223class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.empty()) return \"\"; int min_size = strs[0].length(); for( int i = 0;i&lt;strs.size();i++)&#123; if(strs[i].length()&lt;min_size) min_size = strs[i].length(); &#125; int len = 0; int flag = 1; for(int i=0;i&lt;min_size;i++)&#123; for(int j=0;j&lt;strs.size();j++)&#123; if(strs[j][i]!=strs[0][i]) flag =0; &#125; if(flag) len++; else break; &#125; return strs[0].substr(0,len); &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"LeetCode-13-罗马数字转整数","date":"2016-01-30T07:45:12.000Z","path":"2016/01/30/LeetCode-13/","text":"题目 罗马数字转整数 分析 罗马字符：I-1，V-5，X-10，L-50，C-100，D-500，M-1000注意：4-IV,6-VI所以，需要判断左边的位是否大于右边的位，大于是加，小于是减/ C++代码实现1234567891011121314class Solution &#123;public: int romanToInt(string s) &#123; //Ｉ、Ｖ、Ｘ、Ｌ、Ｃ、Ｄ和Ｍ，分别表示１、５、１０、５０、１００、５００和１０００； map&lt;char,int&gt; a = &#123;&#123;'I',1&#125;,&#123;'V',5&#125;,&#123;'X',10&#125;,&#123;'L',50&#125;,&#123;'C',100&#125;,&#123;'D',500&#125;,&#123;'M',1000&#125;&#125;; int result = a[s[s.length()-1]]; for(int i = s.length()-2;i&gt;=0;i--)&#123; if(a[s[i]]&gt;=a[s[i+1]]) result+=a[s[i]]; else result-=a[s[i]]; &#125; return result; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"LeetCode-12-Integer to Roman","date":"2016-01-30T07:45:09.000Z","path":"2016/01/30/LeetCode-12/","text":"题目 数字转罗马字符 分析 数字在1-3999之间罗马字符：I-1，V-5，X-10，L-50，C-100，D-500，M-1000个位用I和V表示十位用X和L表示百位用C和D表示千位用M表示 C++代码实现12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: string intToRoman(int num) &#123; char a [] =&#123;'I','V','X','L','C','D','M'&#125;; string s = \"\"; int x =0; while(num!=0)&#123; int y = num%10; num/=10; if(y&lt;4)&#123; for(int i=0;i&lt;y;i++)&#123; s+=a[x*2]; &#125; &#125; else if(y==4)&#123; s+=a[x*2+1]; s+=a[x*2]; &#125; else if(y==5)&#123; s+=a[x*2+1]; &#125; else if(y&lt;9)&#123; for(int i=0;i&lt;y-5;i++)&#123; s+=a[x*2]; &#125; s+=a[x*2+1]; &#125; else if(y==9)&#123; s+=a[(x+1)*2]; s+=a[(x)*2]; &#125; x++; &#125; reverse(s.begin(),s.end()); return s; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"LeetCode-10-Regular Expression Matching","date":"2016-01-30T07:45:06.000Z","path":"2016/01/30/LeetCode-10/","text":"题目 正则表达是匹配（.匹配任意字符，*匹配字符有0个或多个） 分析 举例分析：isMatch(“aa”,”a”) → falseisMatch(“aa”,”aa”) → trueisMatch(“aaa”,”aa”) → falseisMatch(“aa”, “a“) → trueisMatch(“aa”, “.“) → trueisMatch(“ab”, “.“) → trueisMatch(“aab”, “ca*b”) → true 设需要匹配的字符串为s，正则表达式为p 当p中的第二个字符为时，如果s[0]==p[0],依次假设前面的字符出现过0次，1次，2次。。。。。直到s[0]!=p[0] 当p中的第二个字符不为*时，进行正常匹配。 C++代码实现1234567891011121314151617181920class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.length()==1) return s==p || (s.length()==1&amp;&amp;p==\".\"); if(p.length()==0) return s==p; switch(p[1])&#123; case '*': while(s.length()!=0 &amp;&amp; (s[0]==p[0] || p[0]=='.'))&#123; if (isMatch(s,p.substr(2,p.length()-1))) return true; s = s.substr(1,s.length()-1); &#125; return isMatch(s,p.substr(2,p.length()-1)); default: if(s[0]==p[0]||(s.length()!=0 &amp;&amp; p[0]=='.')) return isMatch(s.substr(1,s.length()-1),p.substr(1,p.length()-1)); else return false; &#125; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"LeetCode-11- Container With Most Water","date":"2016-01-30T07:45:03.000Z","path":"2016/01/30/LeetCode-11/","text":"题目 给定一个数组，数组的下标代指二维横坐标，数组值代指纵坐标，选取两点，找出组成矩形面积最大值（即，所组成的桶装水的最大值） 分析 利用首尾指针，left,rightheight[left] &lt; height[right]那么left++，否则right– C++代码实现1234567891011121314151617class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int capability = 0; int left = 0; int right = height.size()-1; while(left&lt;right)&#123; int s = min(height[right],height[left]) * (right-left); if(s&gt;capability) capability = s; if(height[left]&lt;height[right]) left++; else right--; &#125; return capability; &#125;&#125;;","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-9-Palindrome Number","date":"2016-01-30T07:45:00.000Z","path":"2016/01/30/LeetCode-9/","text":"题目 判断整数是否是回文数 分析 特殊情况：负数，被10整除的数 C++代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** 字符串反转判断class Solution &#123;public: bool isPalindrome(int x) &#123; stringstream ss; string s; ss&lt;&lt;x;ss&gt;&gt;s;ss.clear(); string sl=s; reverse(s.begin(),s.end()); return sl == s; &#125;&#125;;*//** 整数反转，判断结果与之前是否相等class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0) return false; else&#123; int n = 0; int m = x; while(m!=0)&#123; n=n*10+m%10; m/=10; &#125; return n ==x; &#125; &#125;&#125;;*//** 判断整数的后一半和前一半是否相等*/class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0|| (x!=0 &amp;&amp;x%10==0)) return false; int sum=0; while(x&gt;sum) &#123; sum = sum*10+x%10; x = x/10; &#125; return (x==sum)||(x==sum/10); &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"LeetCode-8-String to Integer (atoi)","date":"2016-01-30T07:44:57.000Z","path":"2016/01/30/LeetCode-8/","text":"题目 字符串转整形 分析 注意：如果越界，返回最大整数或者最小整数 删除字符串前面的空格 判断符号位 判断越界 非法字符 32位有符号整型，第一位是符号位，所以最大整数是 0111 1111 1111 1111 1111 1111 1111 1111 , 2^32 - 1 , 2147483647最小整数是 1000 0000 0000 0000 0000 0000 0000 0000 , - 2^32 , -2147483648 十进制很难记，可以通过移位操作生成。int max = (1 &lt;&lt; 31) - 1;int min = 1 &lt;&lt; 31; C++代码实现12345678910111213141516171819class Solution &#123;public: int myAtoi(string str) &#123; int sign = 1, i = 0; long base = 0; while (str[i] == ' ') &#123; i++; &#125; if (str[i] == '-' || str[i] == '+') &#123; sign = 1 - 2 * (str[i++] == '-'); &#125; while (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') &#123; if (base * 10 + (str[i] - '0') &gt; INT_MAX) &#123;//base必须是long类型，因为最大的整数是2147483647，最小的整数是-2147483648。当输入”2147483648“，base如果定义成int，返回错误，因为无法进入到该判断语句，返回结果为-2147483648 if (sign == 1) return INT_MAX; else return INT_MIN; &#125; base = 10 * base + (str[i++] - '0'); &#125; return base * sign; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"LeetCode-7-Reverse Integer","date":"2016-01-30T07:44:53.000Z","path":"2016/01/30/LeetCode-7/","text":"题目 数字反转，输入123，返回321，输入-123，返回-321 分析 注意特殊情况：10和100整数越界返回0（对于32-bit，1000000003反转后越界） 标记符号位 辗转相除，除10取余，以前的结果×10+余数 最终的结果×符号位 C++代码实现12345678910111213141516class Solution &#123;public: int reverse(int x) &#123; long ret = 0; while(x!=0)&#123; if(ret*10 +x%10&gt;=INT_MAX || ret*10 +x%10&lt;=INT_MIN)&#123; ret = 0;break; &#125; else ret = ret*10 +x%10; x/=10; &#125; return ret; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"LeetCode-6-ZigZag Conversion","date":"2016-01-30T07:44:37.000Z","path":"2016/01/30/LeetCode-6/","text":"题目 之字形字符串转换，给定字符串，以及字符串排列的行数，自顶向下按之字形排列，最后按自左向右按读取，返回结果。 分析 举例分析：输入”PAYPALISHIRING”，3。返回”PAHNAPLSIIGYIR”之字形结果如图所示： 1 2 3 4 5 6 7 P A H N A P L S I I G Y I R 对于字符串str以及rows。字符str[i]所在的行即为i%rows 所以创建长度大小为rows的数组，遍历str，将str[i]分别存储到对应的行里。 将各行拼接得到最终结果。 C++代码实现1234567891011121314151617181920class Solution &#123;public: string convert(string s, int numRows) &#123; string a[numRows]; int len = s.length(); int num = 2*(numRows-1),x=0; string rel = \"\"; if (numRows == 1) return s; for(int i=0; i&lt;len; i++)&#123; x = i%num; if(x&gt;=numRows) a[num-x]+=s[i]; else a[x]+=s[i]; &#125; for(int i =0;i&lt;numRows;i++)&#123; rel+=a[i]; &#125; return rel; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"LeetCode-5-Longest Palindromic Substring","date":"2016-01-18T17:43:58.000Z","path":"2016/01/19/LeetCode-5/","text":"题目 最长回文子串 分析方法1、Manacher’s Algorithm(O(n)) 回文只左右对称的字符串，例如aabbaa.abba,aba,最长回文子串，是指字符串中连续的最长的回文子串。首先需要分奇数偶数情况，为了便于计算，对与给定的字符串，相邻的空闲位置，均插入一个特殊字符，那么字符串的长度变为n*2+1，长度一定是奇数，此时就可以只考虑奇数进行计算。 数组p[i]记录以字符串s[i]为中心的最长回文子串（指向左/向右扩张的子串包括s[i]），也就是回文的半径,举例分析如下： 可以看出p[i]-1正好是原字符串的回文串的总长度 设置辅助变量id和mx，其中 id 为已知的 {右边界最大} 的回文子串的中心，mx则为id+P[id]，也就是这个子串的右边界。 当 mx - i &gt; Pj（即i关于id的对称点） 的时候，以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于 i 和 j 对称，以S[i]为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以必有 P[i] = P[j]，见下图。 当 P[j] &gt;= mx - i 的时候，以S[j]为中心的回文子串不一定完全包含于以S[id]为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 P[i] &gt;= mx - i。至于mx之后的部分是否对称，就只能老老实实去匹配了。 方法2、DP(O(n2)) dp[i][j]表示[i,j]之间的字符串是否为回文串那么规律如下：dp[i][j]=true if i==j=s[i] == s[j] if j == i+1=(s[i] == s[j]) &amp;&amp; (dp[i+1][j-1]) if j &gt; s+1 C++代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/**方法1、Manacher’s Algorithm*/class Solution &#123;public: string longestPalindrome(string s) &#123; string result=\"\"; int len = s.length(); char *tmp = new char[len*2+1]; for(int i =0;i&lt;len*2+1;i++)&#123; tmp[i]=i%2==0?'#':s[(i-1)/2]; &#125; int id=0,mx=0,max_len_id=0; int p[2*len-1]; memset(p,0,sizeof(p)); for(int i=0;i&lt;2*len+1;i++)&#123; if(mx&gt;i) p[i]=min(p[2*id-i],mx-i); else p[i]=1; while(i-p[i]&gt;=0 &amp;&amp; i+p[i]&lt;2*len+1)&#123; if(tmp[i-p[i]]==tmp[i+p[i]]) p[i]++; else break; &#125; if(i+p[i]&gt;mx)&#123; mx = p[i]+i; id=i; &#125; &#125; for(int i=0;i&lt;2*len+1;i++)&#123; if(p[i]&gt;p[max_len_id]) max_len_id = i; &#125; for(int i=max_len_id-p[max_len_id]+1;i&lt;=max_len_id+p[max_len_id]-1;i++)&#123; if(tmp[i]=='#') continue; else result+=tmp[i]; &#125; return result; &#125;&#125;;/**方法2、DP*/class Solution &#123;public: string longestPalindrome(string s) &#123; int len = s.size(); bool dp[len][len]; memset(dp, false, len*len*sizeof(bool)); int maxL=0, start=0, end=0; for(int i =0; i&lt; s.size(); i++) &#123; for(int j =0; j&lt;i; j++) &#123; dp[j][i] = (s[j] == s[i] &amp;&amp; (i-j&lt;2 || dp[j+1][i-1])); if(dp[j][i] &amp;&amp; maxL &lt; (i-j+1)) &#123; maxL = i-j+1; start = j; end = i; &#125; &#125; dp[i][i] =true; &#125; return s.substr(start, end-start +1); &#125; &#125;; 举一反三最长回文子序列 递归实现。 1234567891011121314int lps(char *seq, int i, int j)&#123; //一个元素即为1 if (i == j) return 1; if(i &gt; j) return 0; //因为只计算序列 seq[i ... j] // 如果首尾相同 if (seq[i] == seq[j]) return lps (seq, i+1, j-1) + 2; // 首尾不同 return max( lps(seq, i, j-1), lps(seq, i+1, j) );&#125;","tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"LeetCode-4-Median of Two Sorted Arrays","date":"2016-01-18T08:39:51.000Z","path":"2016/01/18/LeetCode-4/","text":"题目 求解两个排好序的数组的中位数 描述 给定两个数组num1和num2，长度分别为m和n，数组已经排好序，求出两个数组拼接后的中文数，要求：时间复杂度O(log(m+n))解题思路：1、首先假设数组A和B的元素个数都大于k/2，我们比较A[k/2-1]和B[k/2-1]两个元素，这两个元素分别表示A的第k/2小的元素和B的第k/2小的元素。这两个元素比较共有三种情况：&gt;、&lt;和=。如果A[k/2-1]B[k/2-1]时存在类似的结论。3、当A[k/2-1]=B[k/2-1]时，我们已经找到了第k小的数，也即这个相等的元素，我们将其记为m。由于在A和B中分别有k/2-1个元素小于m，所以m即是第k小的数。(这里可能有人会有疑问，如果k为奇数，则m不是中位数。这里是进行了理想化考虑，在实际代码中略有不同，是先求k/2，然后利用k-k/2获得另一个数。) 通过上面的分析，我们即可以采用递归的方式实现寻找第k小的数。此外我们还需要考虑几个边界条件： 如果A或者B为空，则直接返回B[k-1]或者A[k-1]； 如果k为1，我们只需要返回A[0]和B[0]中的较小值； 如果A[k/2-1]=B[k/2-1]，返回其中一个； Java代码实现12345678910111213141516171819202122232425262728public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int total_len = nums1.length + nums2.length; if((total_len &amp; 0x1) == 1)&#123; return findKthNum(nums1, 0, nums1.length - 1, nums2, 0, nums2.length - 1, total_len / 2 + 1); &#125; else&#123; double x = findKthNum(nums1, 0, nums1.length - 1, nums2, 0, nums2.length - 1, total_len / 2); double y = findKthNum(nums1, 0, nums1.length - 1, nums2, 0, nums2.length - 1, total_len / 2 + 1); return (x + y) / 2; &#125; &#125; public double findKthNum(int[] a, int a_start, int a_end, int[] b, int b_start, int b_end, int k)&#123; int len1 = a_end - a_start + 1; int len2 = b_end - b_start + 1; if(len1 &gt; len2) return findKthNum(b, b_start, b_end, a, a_start, a_end, k); if(len1 == 0) return (double)b[b_start + k - 1]; if(k == 1) return (double)Math.min(a[a_start], b[b_start]); int x = Math.min(len1, k / 2); int y = k - x; if(a[a_start + x - 1] &lt; b[b_start + y -1]) return findKthNum(a, a_start + x, a_end, b, b_start, b_end, k - x); else if(a[a_start + x - 1] &gt; b[b_start + y -1]) return findKthNum(a, a_start, a_end, b, b_start + y, b_end, k - y); else return (double)a[a_start + x - 1]; &#125;&#125; Python代码实现123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/python# --*-- coding: utf-8 --*--class Solution(object): def findMedianSortedArrays(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: float \"\"\" length = len(nums1) + len(nums2) if length % 2 == 0: #偶數个元素时，中文数是中间两个数和的平均值 x = self.find_Kth_num(nums1, len(nums1), nums2, len(nums2), length / 2 ) y = self.find_Kth_num(nums1, len(nums1), nums2, len(nums2), length / 2 + 1) return (float(x) + float(y)) / 2 else: return float(self.find_Kth_num(nums1, len(nums1), nums2, len(nums2), length / 2 + 1)) def find_Kth_num(self, nums1, n1, nums2, n2, k): #寻找两个有序数组中第K小的数 if n1 &gt; n2: return self.find_Kth_num(nums2, n2, nums1, n1, k) #保证nums1的长度是最小的 elif n1 == 0: return nums2[k-1] elif k == 1: #此时k/2为0，如果x = min(n1, k/2)结果为0的话，nums1[x-1]数组越界 return min(nums1[0], nums2[0]) else: x = min(n1, k / 2) y = k - x if nums1[x - 1] &lt; nums2[y - 1]: return self.find_Kth_num(nums1[x:], n1 - x, nums2, n2, k - x) elif nums1[x - 1] &gt; nums2[y - 1]: return self.find_Kth_num(nums1, n1, nums2[y:], n2 - y, k - y) else: return nums1[x - 1]","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-3- Longest Substring Without Repeating Characters","date":"2016-01-17T08:39:57.000Z","path":"2016/01/17/LeetCode-3/","text":"题目 输出给定字符串的最长（不含重复元素）子串的长度 描述 给定一个字符串，输出字符串中最长的不含重复元素的子串的长度举例说明输入“abcabcbb”最长结果“abc”，所以返回3对于“bbbbbb”最长结果“b”，所以返回1 Java代码实现12345678910111213141516171819//DP问题，j标记子串的起始点，当遇到重复的元素时，进行不断更新public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap(); int max = 0; int len = s.length(); for (int i = 0, j = 0; i &lt; len; i++) &#123; //j用来标记子串的起始点 if (map.containsKey(s.charAt(i))) &#123; //当存在相同的节点时，j进行更新 j = Math.max(j, map.get(s.charAt(i)) + 1); &#125; map.put(s.charAt(i), i); max = Math.max(max, i - j + 1); &#125; return max; &#125;&#125; Python代码实现123456789101112131415161718class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" note = [-1]*200 x = len(s) sta = -1 max = 0 for i in range(x): m = ord(s[i])-ord(' ') if note[m]&gt;sta: sta = note[m] if i-sta &gt; max: max = i-sta note[m] = i return max C++代码实现1234567891011121314151617181920212223class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int sta= -1; int note[500]; //记录字母出现的最大位置（不断更新） memset(note,-1,sizeof(note)); int len = s.length(); int x; int max = 0; for(int i=0;i&lt;len;i++)&#123; x= s[i] - ' '; if(note[x]&gt;sta)&#123; sta = note[x]; &#125; if(i-sta&gt;max)&#123; max = i-sta; &#125; note[x] = i; &#125; return max; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"LeetCode-2-Add Two Numbers","date":"2016-01-17T08:39:54.000Z","path":"2016/01/17/LeetCode-2/","text":"题目 给定两个链表，输出两个链表对应元素的和，返回结果链表 描述 举例说明输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8 Java代码实现12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode tmp = new ListNode(0); ListNode res = tmp; int x = 0; int sum; while(l1 != null || l2 != null || x != 0) &#123; //切记，不要忘了进位！！！！ sum = x + (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0); x = sum / 10; sum = sum % 10; tmp.next = new ListNode(sum); //注意tmp.next是一个class，需要new进行新建 l1 = l1 != null ? l1.next : null; l2 = l2 != null ? l2.next : null; tmp = tmp.next; &#125; return res.next; &#125;&#125; Python代码实现1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" tmp = ListNode(0) result = tmp x = 0; while(x or l1 or l2): y1 = l1.val if l1 else 0 y2 = l2.val if l2 else 0 sum = (y1+y2+x)%10 x = (y1+y2+x)/10 result.next = ListNode(sum) result = result.next l1 = l1.next if l1 else None l2 = l2.next if l2 else None return tmp.next C++代码实现12345678910111213141516171819class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode tmp(0); struct ListNode *result = &amp;tmp; int x = 0; int sum; while(l1 || l2 || x)&#123; sum = x+(l1?l1-&gt;val:0)+(l2?l2-&gt;val:0); x = sum/10; sum = sum%10; result-&gt;next = new ListNode(sum); result = result-&gt;next; l1 = l1 ? l1-&gt;next: NULL; l2 = l2 ? l2-&gt;next: NULL; &#125; return tmp.next; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yoursite.com/tags/Linked-List/"}]},{"title":"LeetCode-1-Two Sum","date":"2016-01-16T08:39:51.000Z","path":"2016/01/16/LeetCode-1/","text":"题目 对于给定的数组，给定一个target数值，如果数组中的某两个元素的和为target，返回两个元素在数组中的下标 描述 假设输入有唯一的输出！！举例说明给定 nums = [2, 7, 11, 15], target = 9，由于nums[0] + nums[1] = 2 + 7 = 9,所以输出return [0,1] Java代码实现12345678910111213141516public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int [] result = new int[2]; int len = nums.length; HashMap &lt;Integer,Integer&gt; h = new HashMap &lt;Integer,Integer&gt;(); for(int i = 0; i&lt;len; i++)&#123; if(h.containsKey(target-nums[i]))&#123; result[0] = Math.min(h.get(target-nums[i]), i); result[1] = Math.max(h.get(target-nums[i]), i); break; &#125; h.put(nums[i],i); //key=nums[i],value=下表i &#125; return result; &#125;&#125; Python代码实现12345678910111213141516class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" dic = &#123;&#125;; result = []; for i in range(len(nums)): if(dic.has_key(target - nums[i])): result.append( min(dic[target-nums[i]],i) ) result.append( max(dic[target-nums[i]],i) ) else: dic[nums[i]] =i return result","tags":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]}]